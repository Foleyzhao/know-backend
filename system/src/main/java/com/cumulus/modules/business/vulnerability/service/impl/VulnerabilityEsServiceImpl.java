package com.cumulus.modules.business.vulnerability.service.impl;

import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.servlet.http.HttpServletResponse;

import com.alibaba.fastjson.JSONArray;
import com.cumulus.constant.FileConstant;
import com.cumulus.enums.DetailedFileTypeEnum;
import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.controller.AssetStatisticsController;
import com.cumulus.modules.business.entity.Asset;
import com.cumulus.modules.business.repository.AssetRepository;
import com.cumulus.modules.business.service.AssetService;
import com.cumulus.modules.business.vulnerability.dto.VulnerabilityCountDto;
import com.cumulus.modules.business.vulnerability.dto.VulnerabilityDto;
import com.cumulus.modules.business.vulnerability.dto.VulnerabilityQueryDto;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityEsRepository;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityEsService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityHistoryEsService;
import com.cumulus.modules.system.entity.User;
import com.cumulus.modules.system.repository.UserRepository;
import com.cumulus.modules.system.service.DetailedFileService;
import com.cumulus.utils.ExcelResolve;
import com.cumulus.utils.FileUtils;
import com.cumulus.utils.PageUtils;
import com.cumulus.utils.RegexUtil;
import com.cumulus.utils.SecurityUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.RangeQueryBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
import org.elasticsearch.search.sort.SortBuilders;
import org.elasticsearch.search.sort.SortOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.elasticsearch.core.AggregationsContainer;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.data.elasticsearch.core.SearchHits;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.data.elasticsearch.core.query.Query;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

/**
 * 漏洞服务实现类
 *
 * @author zhangxq
 */
@Slf4j
@Service
public class VulnerabilityEsServiceImpl implements VulnerabilityEsService {

    /**
     * 漏洞数据访问接口
     */
    @Autowired
    private VulnerabilityEsRepository vulnerabilityEsRepository;

    /**
     * es查询template
     */
    @Autowired
    private ElasticsearchRestTemplate esRestTemplate;

    /**
     * 资产数据访问接口
     */
    @Autowired
    private AssetRepository assetRepository;

    /**
     * 导出文件服务
     */
    @Autowired
    private DetailedFileService detailedFileService;

    /**
     * 资产服务接口
     */
    @Autowired
    private AssetService assetService;

    /**
     * 用户服务
     */
    @Autowired
    private UserRepository userRepository;

    /**
     * 漏洞历史服务
     */
    @Lazy
    @Autowired
    private VulnerabilityHistoryEsService vulnerabilityHistoryEsService;

    /**
     * integer
     */
    private final static String ES_TYPE_INTEGER = "integer";

    /**
     * date
     */
    private final static String ES_TYPE_DATE = "date";

    /**
     * keyword
     */
    private final static String ES_TYPE_KEYWORD = "keyword";

    /**
     * boolean
     */
    private final static String ES_TYPE_BOOLEAN = "boolean";


    /**
     * 上传excel
     *
     * @param file excel
     * @return 待添加漏洞
     */
    @Override
    public List<VulnerabilityDto> upload(MultipartFile file) {
        JSONArray jsonArray = new JSONArray();
        try {
            jsonArray = new ExcelResolve().readExcel(file);
        } catch (Exception e) {
            e.printStackTrace();
        }
        ObjectMapper objectMapper = new ObjectMapper();
        List<VulnerabilityDto> dtoList = new ArrayList<>();
        if (jsonArray.isEmpty()) {
            log.warn("excel为空");
            return dtoList;
        }
        jsonArray.forEach(obj -> {
            Map<String, String> map = objectMapper.convertValue(obj, Map.class);
            VulnerabilityDto vulnerabilityDto = new VulnerabilityDto();
            if (!map.containsKey("*漏洞名称")) {
                throw new BadRequestException("模板错误");
            }
            vulnerabilityDto.setUuid(UUID.randomUUID().toString());
            vulnerabilityDto.setIp(map.getOrDefault("*关联资产", null));
            vulnerabilityDto.setPort(map.getOrDefault("相关端口", null));
            vulnerabilityDto.setName(map.getOrDefault("*漏洞名称", null));
            vulnerabilityDto.setVulCategory(map.getOrDefault("*漏洞类型", null));
            vulnerabilityDto.setRiskLevel(map.getOrDefault("*漏洞等级", null));
            vulnerabilityDto.setVulType(map.getOrDefault("漏洞分类", null));
            vulnerabilityDto.setIdentifying(map.getOrDefault("漏洞标识", null));
            vulnerabilityDto.setCvssScore(map.getOrDefault("cvss分值", null));
            vulnerabilityDto.setDetail(map.getOrDefault("漏洞细节", null));
            vulnerabilityDto.setDescription(map.getOrDefault("漏洞描述", null));
            vulnerabilityDto.setImpact(map.getOrDefault("漏洞影响", null));
            vulnerabilityDto.setSolution(map.getOrDefault("修复建议", null));
            vulnerabilityDto.setSource("标准模板导入");
            vulnerabilityDto.setResult("待导入");
            dtoList.add(vulnerabilityDto);
        });
        return dtoList;
    }

    /**
     * 导入待添加漏洞
     *
     * @param dtoList 漏洞列表
     * @return 添加结果
     */
    @Override
    public List<VulnerabilityDto> importVulnerability(List<VulnerabilityDto> dtoList) {
        Date date = new Date();
        String userName = SecurityUtils.getCurrentUsername();
        for (VulnerabilityDto dto : dtoList) {
            Asset asset = null;
            VulnerabilityEs vulnerabilityEs = new VulnerabilityEs();
            vulnerabilityEs.setHandleStatus(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
            vulnerabilityEs.setLatest(true);
            vulnerabilityEs.setFindTime(date);
            vulnerabilityEs.setManageTime(date);
            vulnerabilityEs.setCreateTime(date);
            vulnerabilityEs.setUpdateTime(date);
            vulnerabilityEs.setCreateBy(userName);
            vulnerabilityEs.setUpdateBy(userName);
            //来源
            vulnerabilityEs.setSource(VulnerabilityEs.SOURCE_TEMPLATE);
            //端口
            vulnerabilityEs.setPort(dto.getPort());
            Integer port = null;
            if (!"".equals(dto.getPort())) {
                port = Integer.parseInt(vulnerabilityEs.getPort());
                if (port < 1 || port > 65535) {
                    dto.setResult("端口错误");
                    continue;
                }
            }
            //全写ip
            String completeIp = RegexUtil.checkToComplete(dto.getIp(), false);
            if (completeIp == null) {
                dto.setResult("无当前资产");
                continue;
            }
            //漏洞类别
            if (dto.getVulCategory().contains("主机")) {
                vulnerabilityEs.setVulCategory(VulnerabilityEs.CATEGORY_HOST);
                List<Asset> assetList = assetRepository.queryAssetByCompleteIpEqualsAndAssetCategoryEquals(
                        completeIp, 1);
                if (!assetList.isEmpty()) {
                    asset = assetList.get(0);
                }
            } else if (dto.getVulCategory().contains("应用")) {
                vulnerabilityEs.setVulCategory(VulnerabilityEs.CATEGORY_WEB);
                asset = assetRepository.queryAssetByCompleteIpEqualsAndPortEqualsAndAssetCategoryEquals(
                        completeIp, port, 2);
            }
            if (vulnerabilityEs.getVulCategory() == null) {
                dto.setResult("漏洞类型错误");
                continue;
            }
            if (asset == null) {
                dto.setResult("无当前资产");
                continue;
            }
            vulnerabilityEs.setAssetId(asset.getId().toString());
            vulnerabilityEs.setIp(completeIp);
            vulnerabilityEs.setName(dto.getName());
            if (asset.getDept() != null) {
                vulnerabilityEs.setDeptName(asset.getDept().getName());
            }
            //风险等级
            switch (dto.getRiskLevel()) {
                case "低危":
                    vulnerabilityEs.setRiskLevel(VulnerabilityEs.RISK_LEVEL_LOW);
                    break;
                case "中危":
                    vulnerabilityEs.setRiskLevel(VulnerabilityEs.RISK_LEVEL_MID);
                    break;
                case "高危":
                    vulnerabilityEs.setRiskLevel(VulnerabilityEs.RISK_LEVEL_HIGH);
                    break;
                default:
            }
            if (vulnerabilityEs.getRiskLevel() == null) {
                dto.setResult("漏洞等级错误");
                continue;
            }
            //风险详情
            Map<String, Object> detail = new HashMap<>();
            detail.put(VulnerabilityEs.DETAIL_KEY_DESCRIPTION, dto.getDescription());
            detail.put(VulnerabilityEs.DETAIL_KEY_DETAILS, dto.getDetail());
            detail.put(VulnerabilityEs.DETAIL_KEY_IMPACT, dto.getImpact());
            detail.put(VulnerabilityEs.DETAIL_KEY_SOLUTION, dto.getSolution());
            detail.put(VulnerabilityEs.DETAIL_KEY_CVSS_SCORE, dto.getCvssScore());
            detail.put(VulnerabilityEs.DETAIL_KEY_VUL_TYPE, dto.getVulType());
            if (dto.getIdentifying().contains("CVE")) {
                detail.put(VulnerabilityEs.DETAIL_KEY_CVE_NUMBER, dto.getIdentifying());
            } else if (dto.getIdentifying().contains("CNVD")) {
                detail.put(VulnerabilityEs.DETAIL_KEY_CNVD_NUMBER, dto.getIdentifying());
            } else if (dto.getIdentifying().contains("CNNVD")) {
                detail.put(VulnerabilityEs.DETAIL_KEY_CNNVD_NUMBER, dto.getIdentifying());
            } else if (!"".equals(dto.getIdentifying())) {
                vulnerabilityEs.setVulNumber(dto.getIdentifying());
            }
            //风险编号 CVE > CVND > CVNND
            if (detail.containsKey(VulnerabilityEs.DETAIL_KEY_CNNVD_NUMBER)) {
                vulnerabilityEs.setVulNumber(detail.get(VulnerabilityEs.DETAIL_KEY_CNNVD_NUMBER).toString());
            }
            if (detail.containsKey(VulnerabilityEs.DETAIL_KEY_CNVD_NUMBER)) {
                vulnerabilityEs.setVulNumber(detail.get(VulnerabilityEs.DETAIL_KEY_CNVD_NUMBER).toString());
            }
            if (detail.containsKey(VulnerabilityEs.DETAIL_KEY_CVE_NUMBER)) {
                vulnerabilityEs.setVulNumber(detail.get(VulnerabilityEs.DETAIL_KEY_CVE_NUMBER).toString());
            }
            //查重
            if (!"".equals(dto.getIdentifying()) &&
                    vulnerabilityEsRepository.countByAssetIdEqualsAndVulNumberEqualsAndLatestEquals(
                            vulnerabilityEs.getAssetId(), vulnerabilityEs.getVulNumber(), true) > 0) {
                dto.setResult("漏洞重复");
            } else {
                vulnerabilityEs.setDetail(detail);
                vulnerabilityEsRepository.save(vulnerabilityEs);
                vulnerabilityHistoryEsService.vulNewDiscovery(vulnerabilityEs.getId());
                dto.setResult("成功");
                assetService.updateRiskStatus(asset.getId());
            }
        }
        return dtoList.stream().filter(dto -> !"成功".equals(dto.getResult())).collect(Collectors.toList());
    }

    /**
     * 手动新增
     *
     * @param vulnerabilityEs 漏洞对象
     */
    @Override
    public void create(VulnerabilityEs vulnerabilityEs) {
        Asset asset = null;
        //全写ip
        String completeIp = RegexUtil.checkToComplete(vulnerabilityEs.getIp(), false);
        if (completeIp == null) {
            throw new BadRequestException("ip格式错误");
        }
        //主机
        if (vulnerabilityEs.getVulCategory() == VulnerabilityEs.CATEGORY_HOST) {
            List<Asset> assetList = assetRepository.queryAssetByCompleteIpEqualsAndAssetCategoryEquals(
                    completeIp, 1);
            if (!assetList.isEmpty()) {
                asset = assetList.get(0);
            }
        } else {
            //应用
            asset = assetRepository.queryAssetByCompleteIpEqualsAndPortEqualsAndAssetCategoryEquals(
                    completeIp, Integer.parseInt(vulnerabilityEs.getPort()), 2);
        }
        if (asset == null) {
            throw new BadRequestException("无当前资产");
        }
        vulnerabilityEs.setIp(completeIp);
        vulnerabilityEs.setAssetId(asset.getId().toString());
        if (!"".equals(vulnerabilityEs.getVulNumber()) &&
                vulnerabilityEsRepository.countByAssetIdEqualsAndVulNumberEqualsAndLatestEquals(
                        vulnerabilityEs.getAssetId(), vulnerabilityEs.getVulNumber(), true) > 0) {
            throw new BadRequestException("漏洞重复");
        }
        if (asset.getDept() != null) {
            vulnerabilityEs.setDeptName(asset.getDept().getName());
        }
        vulnerabilityEs.setHandleStatus(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        Date date = new Date();
        String userName = SecurityUtils.getCurrentUsername();
        vulnerabilityEs.setFindTime(date);
        vulnerabilityEs.setManageTime(date);
        vulnerabilityEs.setCreateTime(date);
        vulnerabilityEs.setUpdateTime(date);
        vulnerabilityEs.setCreateBy(userName);
        vulnerabilityEs.setUpdateBy(userName);
        vulnerabilityEs.setLatest(true);
        vulnerabilityEsRepository.save(vulnerabilityEs);
        vulnerabilityHistoryEsService.vulNewDiscovery(vulnerabilityEs.getId());
        assetService.updateRiskStatus(asset.getId());
    }

    /**
     * 查询漏洞清单
     *
     * @param dto 查询参数
     * @return 漏洞列表
     */
    @SneakyThrows
    @Override
    public Page<VulnerabilityEs> query(VulnerabilityQueryDto dto, boolean isReport) {
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        if (!isReport) {
            boolQueryBuilder.mustNot(QueryBuilders.termQuery("handleStatus",
                    VulnerabilityEs.HANDLE_STATUS_CLOSED));
        }
        boolQueryBuilder.must(QueryBuilders.termQuery("latest", true));
        //id
        if (ObjectUtils.allNotNull(dto.getId())) {
            boolQueryBuilder.must(QueryBuilders.termQuery("id.keyword", dto.getId()));
        }
        //主机应用
        if (ObjectUtils.allNotNull(dto.getCategory())) {
            if (dto.getCategory() == VulnerabilityEs.CATEGORY_HOST) {
                boolQueryBuilder.must(QueryBuilders.termQuery("vulCategory", VulnerabilityEs.CATEGORY_HOST));
            } else if (dto.getCategory() == VulnerabilityEs.CATEGORY_WEB) {
                boolQueryBuilder.must(QueryBuilders.termQuery("vulCategory", VulnerabilityEs.CATEGORY_WEB));
            }
        }
        //模糊查询
        if (ObjectUtils.allNotNull(dto.getBlurry()) && !dto.getBlurry().isEmpty()) {

            for (Map<String, String> blurryMap : dto.getBlurry()) {
                if (ObjectUtils.allNotNull(blurryMap) && !blurryMap.isEmpty()) {
                    BoolQueryBuilder blurryBuilder = QueryBuilders.boolQuery();
                    for (Map.Entry<String, String> blurry : blurryMap.entrySet()) {
                        blurryBuilder.should(QueryBuilders.wildcardQuery(blurry.getKey(), "*" + blurry.getValue() + "*"));
                    }
                    boolQueryBuilder.filter(blurryBuilder);
                }
            }
        }
        //ip
        if (!StringUtils.isEmpty(dto.getIp())) {
            boolQueryBuilder.must(QueryBuilders.wildcardQuery("ip", "*" + dto.getIp() + "*"));
        }
        //端口
        if (!StringUtils.isEmpty(dto.getPort())) {
            boolQueryBuilder.must(QueryBuilders.wildcardQuery("port", "*" + dto.getPort() + "*"));
        }
        //名称
        if (!StringUtils.isEmpty(dto.getName())) {
            boolQueryBuilder.must(QueryBuilders.wildcardQuery("name", "*" + dto.getName() + "*"));
        }
        //风险等级
        if (dto.getRiskLevel() != null && !dto.getRiskLevel().isEmpty()) {
            boolQueryBuilder.must(QueryBuilders.termsQuery("riskLevel", dto.getRiskLevel()));
        }
        //处理状态
        if (dto.getHandleStatus() != null && !dto.getHandleStatus().isEmpty()) {
            boolQueryBuilder.must(QueryBuilders.termsQuery("handleStatus", dto.getHandleStatus()));
        }
        //风险归属
        if (dto.getDepts() != null && !dto.getDepts().isEmpty()) {
            boolQueryBuilder.must(QueryBuilders.termsQuery("deptName", dto.getDepts()));
        }
        //风险来源
        if (dto.getSource() != null && !dto.getSource().isEmpty()) {
            boolQueryBuilder.must(QueryBuilders.termsQuery("source", dto.getSource()));
        }
        //发现时间
        if (dto.getFindTime() != null && dto.getFindTime().size() == 2) {
            boolQueryBuilder.must(QueryBuilders.rangeQuery("findTime").gte(dto.getFindTime().get(0)).lte(dto.getFindTime().get(1)));
        }
        //风险处置
        if (dto.getIsHandle() != null && dto.getIsHandle()) {
            Long currentUserId = SecurityUtils.getCurrentUserId();
            Optional<User> usrOpt = userRepository.findById(currentUserId);
            if (!usrOpt.isPresent() || usrOpt.get().getIsAdmin() == null || !usrOpt.get().getIsAdmin()) {
                boolQueryBuilder.must(QueryBuilders.termsQuery("handleUser", String.valueOf(currentUserId)));
            }
        }
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder().withPageable(dto.getPageable());
        // 排序字段 默认发现时间倒序
        if (null != dto.getField()) {
            queryBuilder.withSorts(SortBuilders.fieldSort(dto.getField()).order(SortOrder.fromString(dto.getOrder()))
                    .unmappedType(getOrderFieldType(dto.getField())));
        } else {
            queryBuilder.withSorts(SortBuilders.fieldSort("findTime").order(SortOrder.fromString("desc"))
                    .unmappedType(getOrderFieldType("findTime")));
        }
        Query query = queryBuilder.withQuery(boolQueryBuilder).build();
        SearchHits<VulnerabilityEs> searchHits = esRestTemplate.search(query, VulnerabilityEs.class);
        Query countQuery = new NativeSearchQueryBuilder().withQuery(boolQueryBuilder).build();
        long total = esRestTemplate.count(countQuery, VulnerabilityEs.class);
        List<VulnerabilityEs> vulnerabilityEsList = new ArrayList<>();
        searchHits.forEach(hit -> vulnerabilityEsList.add(hit.getContent()));
        return new PageImpl<>(vulnerabilityEsList, dto.getPageable(), total);
    }

    /**
     * 根据字段名获取es排序字段类型
     *
     * @param field 字段名
     * @return 字段类型
     */
    private String getOrderFieldType(String field) {
        String type = "";
        switch (field) {
            case "id":
            case "ip":
            case "port":
            case "name":
            case "vulNumber":
            case "deptName":
                type = ES_TYPE_KEYWORD;
                break;
            case "source":
            case "handleStatus":
            case "riskLevel":
            case "vulCategory":
                type = ES_TYPE_INTEGER;
                break;
            case "latest":
                type = ES_TYPE_BOOLEAN;
                break;
            case "findTime":
                type = ES_TYPE_DATE;
            default:
        }
        return type;
    }

    /**
     * 批量导出
     *
     * @param ids      id列表
     * @param all      是否全部
     * @param response
     */
    @Override
    public void export(Set<String> ids, boolean all, String fileName, HttpServletResponse response) {
        Iterable<VulnerabilityEs> list;
        if (all) {
            list = vulnerabilityEsRepository.findAll();
        } else {
            list = vulnerabilityEsRepository.findAllById(ids);
        }
        try (OutputStream os = response.getOutputStream()) {
            response.setContentType("application/vnd.ms-excel");
            response.setHeader("Content-Disposition", "attachment;filename=" + "file.xls");
            List<List<String>> dataList = new ArrayList<>();
            list.forEach(vulnerability -> {
                Map detail = vulnerability.getDetail();
                if (detail == null) {
                    detail = new HashMap();
                }
                dataList.add(Arrays.asList(
                        vulnerability.getId(),
                        vulnerability.getIp(),
                        vulnerability.getName(),
                        String.valueOf(detail.getOrDefault(VulnerabilityEs.DETAIL_KEY_DETAILS, "")),
                        String.valueOf(detail.getOrDefault(VulnerabilityEs.DETAIL_KEY_DESCRIPTION, "")),
                        String.valueOf(detail.getOrDefault(VulnerabilityEs.DETAIL_KEY_IMPACT, "")),
                        String.valueOf(detail.getOrDefault(VulnerabilityEs.DETAIL_KEY_SOLUTION, "")),
                        vulnerability.getVulNumber(),
                        String.valueOf(vulnerability.getFindTime()),
                        getHandleStatus(vulnerability.getHandleStatus()),
                        vulnerability.getManageTime().toString(),
                        vulnerability.getDeptName()
                ));
            });
            String[] title = {"序号", "资产IP", "漏洞名称", "漏洞细节", "漏洞描述", "漏洞影响", "解决方案",
                    "漏洞标识", "发现时间", "处理状态", "处置时间", "所属部门"};
            HSSFWorkbook workbook = new HSSFWorkbook();
            FileUtils.exportExcel(workbook, 0, "sheet1", title, dataList, false);
            detailedFileService.saveDetailedFile(
                    DetailedFileTypeEnum.VULNERABILITY_LIST, fileName, FileConstant.EXCEL_SUFFIX_XLS, workbook);
            workbook.write(os);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 根据id获取处理状态名称
     *
     * @param i 处理状态值
     * @return 名称
     */
    private String getHandleStatus(int i) {
        String name = "";
        switch (i) {
            case VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED:
                name = "待下发";
                break;
            case VulnerabilityEs.HANDLE_STATUS_TO_REPAIR:
                name = "待修复";
                break;
            case VulnerabilityEs.HANDLE_STATUS_TO_RETEST:
                name = "待复测";
                break;
            case VulnerabilityEs.HANDLE_STATUS_REPAIR:
                name = "已修复";
                break;
            case VulnerabilityEs.HANDLE_STATUS_IGNORED:
                name = "已忽略";
                break;
            case VulnerabilityEs.HANDLE_STATUS_CLOSED:
                name = "关闭";
                break;
            default:
        }
        if ("".equals(name)) {
            log.info("处理状态错误：" + i);
        }
        return name;
    }

    @Override
    public void updateLatestByVulCategoryAndId(Integer vulCategory, String ip) {
        List<VulnerabilityEs> vulnerabilityEsList = vulnerabilityEsRepository.
                findAllByVulCategoryAndIpAndLatestEquals(vulCategory, ip, true);
        for (VulnerabilityEs vulnerabilityEs : vulnerabilityEsList) {
            vulnerabilityEs.setLatest(false);
        }
        vulnerabilityEsRepository.saveAll(vulnerabilityEsList);
    }

    /**
     * 漏洞清单统计
     *
     * @param vulCategory 漏洞类型
     * @return 统计数据传输对象
     */
    @Override
    public VulnerabilityCountDto countVulnerability(Integer vulCategory) {
        //待下发
        Set<Integer> toIssuedSet = new HashSet<>(Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED));
        VulnerabilityCountDto.SingleCnt toIssued = countSingleCnt(vulCategory, toIssuedSet);
        //待修复
        Set<Integer> toRepairSet = new HashSet<>(Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_TO_REPAIR));
        VulnerabilityCountDto.SingleCnt toRepair = countSingleCnt(vulCategory, toRepairSet);
        //已修复
        Set<Integer> repairSet = new HashSet<>(Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_REPAIR));
        repairSet.add(VulnerabilityEs.HANDLE_STATUS_TO_RETEST);
        VulnerabilityCountDto.SingleCnt repair = countSingleCnt(vulCategory, repairSet);
        //已忽略
        Set<Integer> ignoredSet = new HashSet<>(Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_IGNORED));
        VulnerabilityCountDto.SingleCnt ignored = countSingleCnt(vulCategory, ignoredSet);
        return new VulnerabilityCountDto(toIssued, toRepair, repair, ignored);
    }

    @Override
    public List<Map<String, Long>> countVulNumber(Integer dateType) {
        return getCount(dateType);
    }

    /**
     * 统计
     *
     * @return 结果
     */
    private List<Map<String, Long>> getCount(Integer dateType) {
        List<Map<String, Long>> listMap = new ArrayList<>();
        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();
        boolQueryBuilder.must(QueryBuilders.termQuery("latest", true));
        Date date = new Date();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        switch (dateType) {
            case AssetStatisticsController.DATE_TYPE_DAY:
                calendar.add(Calendar.DATE, -1);
                break;
            case AssetStatisticsController.DATE_TYPE_WEEK:
                calendar.add(Calendar.DATE, -7);
                break;
            case AssetStatisticsController.DATE_TYPE_MONTH:
                calendar.add(Calendar.DATE, -30);
                break;
            case AssetStatisticsController.DATE_TYPE_HALF_YEAR:
                calendar.add(Calendar.DATE, -180);
                break;
            default:
                break;
        }
        if (AssetStatisticsController.DATE_TYPE_ALL != dateType) {
            RangeQueryBuilder updateDate = QueryBuilders.rangeQuery("findTime")
                    .gte(calendar.getTime())
                    .lte(date);
            boolQueryBuilder.must(updateDate);
        }
        TermsAggregationBuilder agg = AggregationBuilders.terms("vulNumber").field("vulNumber").size(10);
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder().withAggregations(agg);
        Query query = queryBuilder.withQuery(boolQueryBuilder).build();
        SearchHits<VulnerabilityEs> search = esRestTemplate.search(query, VulnerabilityEs.class);
        AggregationsContainer<?> aggregations = search.getAggregations();
        Aggregations aggregations1 = (Aggregations) aggregations.aggregations();
        Terms name = aggregations1.get("vulNumber");
        List<? extends Terms.Bucket> buckets = name.getBuckets();
        for (Terms.Bucket bucket : buckets) {
            Map<String, Long> map = new HashMap<>();
            map.put(bucket.getKey().toString(), bucket.getDocCount());
            listMap.add(map);
        }
        return listMap;
    }

    /**
     * 根据id查询
     *
     * @param id id
     * @return 漏洞
     */
    @Override
    public VulnerabilityEs findById(String id) {
        VulnerabilityEs vulnerabilityEs = vulnerabilityEsRepository.findById(id).orElse(null);
        return vulnerabilityEs;
    }

    /**
     * 根据ip查询风险
     *
     * @param ip       ip
     * @param pageable 分页参数
     * @return 风险详情
     */
    @Override
    public Object findByIp(String ip, Pageable pageable) {
        if ("".equals(ip)) {
            throw new BadRequestException("IP不能为空");
        }
        ip = RegexUtil.checkToComplete(ip, true);
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        //去除 处理状态为关闭的
        boolQueryBuilder.mustNot(QueryBuilders.termQuery("handleStatus",
                VulnerabilityEs.HANDLE_STATUS_CLOSED));
        //只查最新的
        boolQueryBuilder.must(QueryBuilders.termQuery("latest", true));
        //ip
        boolQueryBuilder.must(QueryBuilders.termQuery("ip", ip));
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder().withPageable(pageable);
        //按发现时间倒序
        queryBuilder.withSorts(SortBuilders.fieldSort("findTime").order(SortOrder.fromString("desc"))
                .unmappedType(ES_TYPE_DATE));
        Query query = queryBuilder.withQuery(boolQueryBuilder).build();
        SearchHits<VulnerabilityEs> searchHits = esRestTemplate.search(query, VulnerabilityEs.class);
        Query countQuery = new NativeSearchQueryBuilder().withQuery(boolQueryBuilder).build();
        long total = esRestTemplate.count(countQuery, VulnerabilityEs.class);
        List<VulnerabilityEs> vulnerabilityEsList = new ArrayList<>();
        searchHits.forEach(hit -> vulnerabilityEsList.add(hit.getContent()));
        return PageUtils.toPage(vulnerabilityEsList, total);
    }

    @Override
    public void saveById(VulnerabilityEs vul) {
        Optional<VulnerabilityEs> vulOpt = vulnerabilityEsRepository.findById(vul.getId());
        if (vulOpt.isPresent()) {
            vul.setUpdateTime(new Date());
            try {
                vul.setUpdateBy(SecurityUtils.getCurrentUsername());
            } catch (Exception e) {
                vul.setUpdateBy(User.DEFAULT_SUPER_MANAGER_NAME);
            }
            vulnerabilityEsRepository.save(vul);
        }
    }

    /**
     * 计算单项统计结果
     *
     * @param vulCategory     漏洞类型
     * @param handleStatusSet 处理状态set
     * @return 单项统计对象
     */
    private VulnerabilityCountDto.SingleCnt countSingleCnt(Integer vulCategory, Set<Integer> handleStatusSet) {
        //低
        Long low = vulnerabilityEsRepository.
                countByVulCategoryEqualsAndRiskLevelEqualsAndHandleStatusIsInAndLatestEquals(
                        vulCategory, VulnerabilityEs.RISK_LEVEL_LOW, handleStatusSet, true);
        //中
        Long mid = vulnerabilityEsRepository.
                countByVulCategoryEqualsAndRiskLevelEqualsAndHandleStatusIsInAndLatestEquals(
                        vulCategory, VulnerabilityEs.RISK_LEVEL_MID, handleStatusSet, true);
        //高
        Long high = vulnerabilityEsRepository.
                countByVulCategoryEqualsAndRiskLevelEqualsAndHandleStatusIsInAndLatestEquals(
                        vulCategory, VulnerabilityEs.RISK_LEVEL_HIGH, handleStatusSet, true);
        //风险等级统计对象
        VulnerabilityCountDto.RiskLevel riskLevel = new VulnerabilityCountDto.RiskLevel(low, mid, high);
        return new VulnerabilityCountDto.SingleCnt(riskLevel.getTotal(), riskLevel);
    }

}
