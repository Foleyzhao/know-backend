package com.cumulus.modules.business.vulnerability.entity;

import com.cumulus.annotation.SizeChinese;
import com.cumulus.base.BaseEntity;
import com.cumulus.modules.business.entity.Asset;
import com.cumulus.modules.quartz.entity.QuartzJob;
import com.cumulus.modules.system.entity.Dept;
import com.cumulus.mysql.userType.JsonType;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.annotations.Parameter;
import org.hibernate.annotations.Type;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Null;
import java.io.Serializable;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 漏扫计划实体
 *
 * @author zhaoff
 */
@Getter
@Setter
@Entity
@ToString
@Table(name = "tbl_vulnerability_scan_plan")
public class ScanPlan extends BaseEntity implements Serializable {

    /**
     * 扫描状态： 0：未扫描 1：扫描中 2：暂停 3、结束
     */
    public static final int SCAN_NOT = 0;
    public static final int SCAN_RUNNING = 1;
    public static final int SCAN_PAUSE = 2;
    public static final int SCAN_FINISH = 3;

    /**
     * 扫描类型 0全部 1根据部门 2自定义
     */
    public static final int SCAN_TYPE_ALL = 0;
    public static final int SCAN_TYPE_BY_DEPT = 1;
    public static final int SCAN_TYPE_CUSTOM = 2;
    public static final String SCAN_TYPE_ALL_STR = "全部";
    public static final String SCAN_TYPE_BY_DEPT_STR = "按部门";
    public static final String SCAN_TYPE_CUSTOM_STR = "自定义";

    /**
     * 定时类型 1、手动 2、每月 3、每周 4、自定义
     */
    public static final int MONITORING_TYPE_MANUAL = 1;
    public static final int MONITORING_TYPE_MONTHLY = 2;
    public static final int MONITORING_TYPE_WEEKLY = 3;
    public static final int MONITORING_TYPE_CUSTOM = 4;

    /**
     * 字段限制长度
     */
    public static final int NAME_MAX_SIZE = 20;

    /**
     * 单个任务最多的任务量
     */
    public static final int PLAN_ASSET_MAX_SUM = 3000;

    private static final long serialVersionUID = -666229694056697559L;

    /**
     * ID
     */
    @NotNull(groups = Update.class, message = "更新任务需要id")
    @Null(groups = Create.class, message = "新建任务不需要id")
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 计划名称
     */
    @SizeChinese(groups = {Create.class, Update.class}, max = NAME_MAX_SIZE, message = "任务名称长度有误")
    @NotNull(groups = Create.class, message = "创建任务需要名称")
    private String name;

    /**
     * 扫描计划和扫描器对应关系
     */
    @ManyToOne
    @JoinColumn(name = "scanner_id")
    private Scan scanner;

    /**
     * 扫描策略 ID 第三方漏扫器的策略
     */
    @NotNull(groups = Create.class, message = "创建任务需要策略")
    private Integer policyId;

    /**
     * 计划执行状态, 0: 正在执行， 1:执行结束， 2:未执行
     */
    private Integer status;

    /**
     * 漏洞扫描计划的其他扩展属性
     **/
    @Type(type = JsonType.JSON_TYPE_CLASS_PATH)
    private Map<String, Object> extra = new HashMap<>();

    /**
     * 创建时间
     */
    private Timestamp createTime;

    /**
     * 定时任务 id
     */
    @OneToOne
    @JoinColumn(name = "quartz_job_id")
    private QuartzJob quartzJob;

    /**
     * 自定义时的资产列表
     */
    @ManyToMany
    @JoinTable(name = "tbl_vulnerability_plan_asset",
            joinColumns = {@JoinColumn(name = "plan_id", referencedColumnName = "id")},
            inverseJoinColumns = {@JoinColumn(name = "asset_id", referencedColumnName = "id")})
    private List<Asset> scanAsset;

    /**
     * 按部门时的部门列表
     */
    @ManyToMany
    @JoinTable(name = "tbl_vulnerability_plan_dept",
            joinColumns = {@JoinColumn(name = "plan_id", referencedColumnName = "id")},
            inverseJoinColumns = {@JoinColumn(name = "dept_id", referencedColumnName = "id")})
    private List<Dept> scanDept;

    /**
     * 0全部, 1 按部门, 2 自定义
     */
    @NotNull(groups = Create.class, message = "创建任务需要扫描对象")
    private Integer scanType;

    /**
     * 上次执行时间
     */
    private Date lastTime;

    /**
     * 下次执行时间
     */
    private Date nextTime;

    /**
     * 定时类型 1、手动 2、每月 3、每周 4、自定义
     */
    @NotNull(groups = Create.class, message = "创建任务需要定时类型")
    private Integer monitoringType;

    /**
     * 定时的具体数据 每周代表具体的周数 自定义则存一个 间隔时间 单位 天
     */
    @Type(type = JsonType.JSON_TYPE_CLASS_PATH, parameters = {
            @Parameter(name = "type", value = "LIST"),
            @Parameter(name = "element", value = "java.lang.Integer")
    })
    private List<Integer> monitoringParam;

    /**
     * 运行中或上次运行的漏洞扫描计划结果
     */
    private Long runningOrLastResultId;

    /**
     * 是否使用内置的 true：内置 false：第三方
     */
    @NotNull(groups = Create.class, message = "创建任务需要指定扫描器")
    private Boolean builtIn;

    /**
     * 开始时间
     */
    private Date startTime;

    /**
     * 获取开始时间
     */
    public Date startTime() {
        Date startTime = lastTime;
        if (startTime == null) {
            startTime = createTime;
        }
        if (startTime == null) {
            startTime = new Date();
        }
        return runTime(startTime);
    }

    /**
     * 将入参的时间的 秒分时变为 startTime 中的 时分秒
     *
     * @param time 时间
     * @return 返回时间
     */
    public Date runTime(Date time) {
        if (this.startTime != null) {
            Calendar startTime = Calendar.getInstance();
            startTime.setTime(this.startTime);
            Calendar now = Calendar.getInstance();
            now.setTime(time);
            now.set(Calendar.HOUR_OF_DAY, startTime.get(Calendar.HOUR_OF_DAY));
            now.set(Calendar.MINUTE, startTime.get(Calendar.MINUTE));
            now.set(Calendar.SECOND, startTime.get(Calendar.SECOND));
            return now.getTime();
        }
        return time;
    }

    /**
     * 生成上次扫描时间
     */
    public void lastTime() {
        Date now = new Date();
        if (this.nextTime == null || this.nextTime.after(now)) {
            //nextTime 不为空且 下次执行时间大于当前执行时间则说明是手动执行
            this.setLastTime(now);
        } else {
            this.setLastTime(runTime(now));
        }
    }
}
