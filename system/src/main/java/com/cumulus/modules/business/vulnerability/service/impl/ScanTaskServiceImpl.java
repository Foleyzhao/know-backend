package com.cumulus.modules.business.vulnerability.service.impl;

import com.cumulus.enums.MessageTypeEnum;
import com.cumulus.enums.ScanProduct;
import com.cumulus.modules.business.vulnerability.dto.ScanTaskRequest;
import com.cumulus.modules.business.vulnerability.entity.Scan;
import com.cumulus.modules.business.vulnerability.entity.ScanPlan;
import com.cumulus.modules.business.vulnerability.entity.ScanResult;
import com.cumulus.modules.business.vulnerability.repository.AssetScanResultRepository;
import com.cumulus.modules.business.vulnerability.repository.ScanRepository;
import com.cumulus.modules.business.vulnerability.service.AssetScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanPlanService;
import com.cumulus.modules.business.vulnerability.service.ScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanTaskService;
import com.cumulus.modules.business.vulnerability.support.VulnerabilityScanProvider;
import com.cumulus.modules.system.entity.Menu;
import com.cumulus.modules.system.service.MessageService;
import com.cumulus.utils.DateUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import javax.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 漏洞扫描任务服务实现
 *
 * @author zhaoff
 */
@Slf4j
@Service
@CacheConfig(cacheNames = "scanTask")
public class ScanTaskServiceImpl implements ScanTaskService, ApplicationContextAware {

    /**
     * 漏洞扫描功能提供者MAP
     */
    private Map<String, VulnerabilityScanProvider> vulnerabilityScanProviders;

    /**
     * 漏洞扫描器数据访问对象
     */
    @Autowired
    private ScanRepository scannerRepository;

    /**
     * 扫描任务服务层
     */
    @Autowired
    private ScanPlanService scanPlanService;

    /**
     * 单个扫描结果服务层
     */
    @Autowired
    private AssetScanResultService assetScanResultService;

    /**
     * 扫描结果服务层
     */
    @Autowired
    private ScanResultService scanResultService;

    /**
     * 单个扫描结果数据接口
     */
    @Autowired
    private AssetScanResultRepository assetScanResultRepository;

    /**
     * 系统消息服务层
     */
    @Autowired
    private MessageService messageService;

    @Override
    public void setApplicationContext(ApplicationContext appContext) throws BeansException {
        List<VulnerabilityScanProvider> list = new ArrayList<>(
                BeanFactoryUtils.beansOfTypeIncludingAncestors(appContext, VulnerabilityScanProvider.class).values());
        vulnerabilityScanProviders = new HashMap<>(list.size());
        for (VulnerabilityScanProvider provider : list) {
            vulnerabilityScanProviders.put(provider.getSupportCode(), provider);
        }
    }

    @Override
    public void batchAddActiveScan(ScanTaskRequest request) throws Exception {
        VulnerabilityScanProvider provider = getVulnerabilityScanProvider(request);
        if (null == provider) {
            if (log.isErrorEnabled()) {
                log.error("No usable provider for plan: " + request.getPlanId());
            }
            throw new Exception("任务启动失败");
        }
        request.setProvider(provider);
        provider.batchAddScanTask(request);
    }

    @Override
    public void batchGetScanResult(ScanTaskRequest request) {
        VulnerabilityScanProvider provider = getVulnerabilityScanProvider(request);
        if (null == provider) {
            if (log.isErrorEnabled()) {
                log.error("No usable provider for planId:" + request.getPlanId());
            }
            return;
        }
        provider.batchGetScanResult(request);
    }

    @Override
    @Cacheable(value = "scan-task#60", key = "'get-strategies:' + #p0.product + ':' + #p0.version")
    public List<Map<String, Object>> getStrategies(Scan scanner) throws Exception {
        log.info("getStrategies not ust cache");
        try {
            VulnerabilityScanProvider provider = vulnerabilityScanProviders.get(String.valueOf(scanner.getProduct()));
            return provider.getStrategies(scanner);
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error("Get strategies Exception: " + e.getMessage());
            }
            throw e;
        }
    }

    @Override
    public List<Map<String, Object>> getName() {
        List<Map<String, Object>> mapList = new ArrayList<>();
        Map<@NotNull String, Long> collect = scannerRepository.findAll().stream().collect(Collectors.toMap(Scan::getName, Scan::getId, (name, id) -> name));
        for (Map.Entry<String, Long> stringIntegerEntry : collect.entrySet()) {
            HashMap<String, Object> map = new HashMap<>();
            map.put("id", stringIntegerEntry.getValue());
            map.put("scanName", stringIntegerEntry.getKey());
            mapList.add(map);
        }
        return mapList;
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public boolean tryUpdateTaskStatusEnd(Long planId) {
        ScanPlan scanPlan = scanPlanService.getScanPlanById(planId);
        if (null == scanPlan) {
            throw new RuntimeException("任务不存在");
        }
        Long scanResultId = scanPlan.getRunningOrLastResultId();
        if (null == scanResultId) {
            try {
                scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_FINISH);
            } catch (Exception e) {
                return false;
            }
            return true;
        } else {
            Integer count = assetScanResultService.countAllByScanResultAndResultScanning(scanResultId);
            if (count != null && count == 0) {
                try {
                    scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_FINISH);
                } catch (Exception e) {
                    return false;
                }
                scanResultService.updateScanResultStatus(scanResultId, ScanResult.RESULT_SUCCESS);
                return true;
            }
            messageService.sendMessage(MessageTypeEnum.VUL_SCAN_END_TYPE, Menu.DEFAULT_VUL_SCAN_MENU_ID, Collections.singletonList(String.valueOf(scanPlan.getId())),
                    scanPlan.getName(), DateUtils.SIMPLE_DFY_MD_HMS.format(new Date()));
        }
        return false;
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public void updateTaskStatusPause(Long planId) {
        ScanPlan scanPlan = scanPlanService.getScanPlanById(planId);
        if (null == scanPlan) {
            throw new RuntimeException("任务不存在");
        }
        scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_PAUSE);
        Long scanResultId = scanPlan.getRunningOrLastResultId();
        assetScanResultRepository.updateStatusPauseByScanResultId(scanResultId);
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public void updateTaskStatusRestart(Long planId) {
        ScanPlan scanPlan = scanPlanService.getScanPlanById(planId);
        if (null == scanPlan) {
            throw new RuntimeException("任务不存在");
        }
        scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_RUNNING);
        Long scanResultId = scanPlan.getRunningOrLastResultId();
        assetScanResultRepository.updateStatusRestartByScanResultId(scanResultId);
    }

    @Override
    @Transactional(rollbackOn = Exception.class)
    public void updateTaskStatusErrorEnd(Long planId, Integer scanResultResultCode, Integer assetScanResultCode) {
        ScanPlan scanPlan = scanPlanService.getScanPlanById(planId);
        if (null == scanPlan) {
            throw new RuntimeException("任务不存在");
        }
        scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_FINISH);
        Long scanResultId = scanPlan.getRunningOrLastResultId();
        if (null != scanResultId) {
            scanResultService.updateScanResultStatus(scanResultId, scanResultResultCode);
            assetScanResultRepository.updateStatusCancelByScanResultId(scanResultId);
            assetScanResultRepository.updateResultByScanResultId(scanResultId, assetScanResultCode);
        }
    }

    /**
     * 获取漏扫任务控制器
     *
     * @param request 任务请求
     * @return 漏扫任务控制器
     */
    private VulnerabilityScanProvider getVulnerabilityScanProvider(ScanTaskRequest request) {
        if (request == null) {
            return null;
        }
        //初始化 request 的 Extra 字段，避免 null 报错
        if (request.getExtra() == null) {
            request.setExtra(new HashMap<>(1));
        }
        //内置直接返回
        if (request.getResult().isBuiltIn()) {
            return vulnerabilityScanProviders.get(String.valueOf(ScanProduct.BUILTIN_PRODUCT_ID));
        }
        //第三方则需要查询扫描器信息
        Scan scanner = (Scan) request.getExtra().get("scanner");
        if (null == scanner && request.getScannerId() != null) {
            scanner = scannerRepository.findById(request.getScannerId()).orElse(null);
            request.getExtra().put("scanner", scanner);
        }
        if (null == scanner) {
            if (log.isErrorEnabled()) {
                log.error("Scanner not exist");
            }
            return null;
        }
        VulnerabilityScanProvider provider = vulnerabilityScanProviders.get(String.valueOf(scanner.getProduct()));
        if (null == provider) {
            if (log.isErrorEnabled()) {
                log.error("No usable provider for scanner:" + scanner.getProduct());
            }
        }
        return provider;
    }

}
