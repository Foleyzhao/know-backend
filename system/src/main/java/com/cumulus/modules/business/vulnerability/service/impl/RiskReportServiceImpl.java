package com.cumulus.modules.business.vulnerability.service.impl;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import com.cumulus.config.FileProperties;
import com.cumulus.config.thread.TheadFactoryName;
import com.cumulus.constant.FileConstant;
import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.dto.BatchPackage;
import com.cumulus.modules.business.entity.Asset;
import com.cumulus.modules.business.repository.AssetRepository;
import com.cumulus.modules.business.service.AssetService;
import com.cumulus.modules.business.vulnerability.dto.RiskReportDto;
import com.cumulus.modules.business.vulnerability.dto.VulnerabilityQueryDto;
import com.cumulus.modules.business.vulnerability.entity.RiskReport;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.mapstruct.RiskReportMapper;
import com.cumulus.modules.business.vulnerability.repository.RiskReportRepository;
import com.cumulus.modules.business.vulnerability.service.RiskReportService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityEsService;
import com.cumulus.modules.system.entity.Dept;
import com.cumulus.modules.system.repository.DeptRepository;
import com.cumulus.modules.system.service.UserService;
import com.cumulus.utils.DateUtils;
import com.cumulus.utils.FileUtils;
import com.cumulus.utils.RegexUtil;
import com.cumulus.utils.WKHtmlToPdfUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.Aggregations;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;
import org.springframework.data.elasticsearch.core.SearchHits;
import org.springframework.data.elasticsearch.core.query.NativeSearchQueryBuilder;
import org.springframework.data.elasticsearch.core.query.Query;
import org.springframework.stereotype.Service;

/**
 * 风评报告服务实现
 *
 * @author zhangxq
 */
@Service
@Slf4j
public class RiskReportServiceImpl implements RiskReportService {

    /**
     * 风评报告数据访问接口
     */
    @Resource
    private RiskReportRepository reportRepository;

    /**
     * 风评报告mapper
     */
    @Resource
    private RiskReportMapper reportMapper;

    /**
     * 系统文件属性配置
     */
    @Autowired
    private FileProperties fileProperties;

    /**
     * 资产数据访问接口
     */
    @Autowired
    private AssetRepository assetRepository;

    /**
     * 部门数据访问接口
     */
    @Autowired
    private DeptRepository deptRepository;

    /**
     * es查询template
     */
    @Autowired
    private ElasticsearchRestTemplate esRestTemplate;

    /**
     * 漏洞服务
     */
    @Autowired
    private VulnerabilityEsService vulnerabilityEsService;

    /**
     * 用户服务
     */
    @Autowired
    private UserService userService;

    /**
     * 资产服务
     */
    @Autowired
    private AssetService assetService;

    /**
     * html转pdf
     */
    @Autowired
    private WKHtmlToPdfUtil wkHtmlToPdfUtil;

    /**
     * 类型名称 1 主机 2 应用 3 全部
     */
    private static final String[] TYPES = {"", "主机漏洞", "应用漏洞", "主机漏洞、应用漏洞"};

    /**
     * 状态名称 0 正在生成 1 完成 2 失败
     */
    private static final String[] STATUSNAME = {"正在生成", "完成", "失败"};

    /**
     * 部门分隔符
     */
    private static final String SEPARATE_STR = ",";

    /**
     * 风险top10
     */
    private static final String RISK_TOP10_HEAD = "<table class=\"my-table custom-content\"><tbody><tr><th width=\"17%\">资产</th><th width=\"16%\">负责人</th><th width=\"16%\"class=\"red\">高危</th><th width=\"16%\"class=\"yellow\">中危</th><th width=\"16%\"class=\"blue\">低危</th><th width=\"16%\">合计</th></tr>";
    private static final String RISK_TOP10_TAIL = "</tbody></table>";

    private static final String HTML_TR1 = "<tr>";
    private static final String HTML_TR2 = "</tr>";
    private static final String HTML_TD1 = "<td>";
    private static final String HTML_TD2 = "</td>";

    /**
     * 漏洞详情
     */
    private static final String DETAIL_HEAD_BORDER_TOP_NONE =
            "<table class=\"my-table custom-content border-top-none \"><tbody>";
    private static final String DETAIL_HEAD = "<table class=\"my-table custom-content\"><tbody>";
    private static final String DETAIL_TAIL = "</tbody></table>";
    private static final String HTML_TH1 = "<th class=\"vulnerability-details-title\" colspan=\"2\">";
    private static final String HTML_TH2 = "</th>";

    private static final String DETAIL_KEY_TD = "<td width=\"20%\" class=\"custom-td\">";
    private static final String DETAIL_VALUE_TD = "<td class=\"custom-td-vul vul-detail \">";

    private static final String AFFECT_ASSETS = "影响资产";
    private static final String CVE_NAME = "CVE/CNVD";
    private static final String DESC_NAME = "漏洞描述";
    private static final String DETAIL_NAME = "漏洞细节";
    private static final String AFFECT_NAME = "漏洞影响";
    private static final String ADVICE_NAME = "处置建议";

    /**
     * 1 MB
     */
    private static final long MB = 1048576;

    /**
     * 线程
     */
    @Autowired
    private final TheadFactoryName theadFactory = new TheadFactoryName();

    /**
     * 查询所有
     *
     * @param pageable 分页参数
     * @return 风险报告列表
     */
    @Override
    public Page<RiskReportDto> query(Pageable pageable) {
        return reportRepository.findAll(pageable).map(e -> {
            RiskReportDto dto = reportMapper.toDto(e);
            if (e.getType() == RiskReport.TYPE_ALL) {
                dto.setTypes(new Integer[]{RiskReport.TYPE_HOST, RiskReport.TYPE_WEB});
            } else {
                dto.setTypes(new Integer[]{e.getType()});
            }
            dto.setTypeName(TYPES[e.getType()]);
            dto.setRangeName(getAssetRange(e.getRange(), e.getRangeList()));
            dto.setStatusName(STATUSNAME[dto.getStatus()]);
            return dto;
        });
    }

    /**
     * 新增报表
     *
     * @param dto 报表数据传输对象
     */
    @Override
    public void addReport(RiskReportDto dto) {
        //ip校验
        if (dto.getRange() == RiskReport.RANGE_SINGLE) {
            RegexUtil.checkToComplete(dto.getRangeList(), true);
        }
        if (dto.getTypes().length > 1) {
            dto.setType(RiskReport.TYPE_ALL);
        } else {
            dto.setType(dto.getTypes()[0]);
        }
        RiskReport riskReport = reportMapper.toEntity(dto);
        riskReport.setStatus(RiskReport.STATUS_RUNNING);
        riskReport.setFileName(UUID.randomUUID().toString());
        if (reportRepository.countByNameEquals(riskReport.getName()) > 0) {
            throw new BadRequestException("报表名称重复！");
        }
        reportRepository.save(riskReport);
        //异步生成报表
        asyncCreate(riskReport);
    }

    /**
     * 异步生成报表 html、pdf
     *
     * @param riskReport
     */
    private void asyncCreate(RiskReport riskReport) {
        //异步生成报表
        theadFactory.newThread(() -> {
            boolean flag = createReport(riskReport);
            if (flag) {
                riskReport.setStatus(RiskReport.STATUS_DONE);
                log.info("生成风评报告：{}.html", riskReport.getFileName());
                //生成pdf
                String htmlPath = generateFilePath(riskReport.getFileName(), FileConstant.HTML_SUFFIX_HTML);
                String pdfPath = generateFilePath(riskReport.getFileName(), FileConstant.PDF_SUFFIX);
                wkHtmlToPdfUtil.htmlToPdf(htmlPath, pdfPath);
                File htmlFile = new File(htmlPath);
                long sleep = htmlFile.length() / MB;
                try {
                    Thread.sleep((sleep + 1) * 5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                File pdfFile = new File(pdfPath);
                if (!pdfFile.exists()) {
                    log.info("生成风评报告PDF失败：{}", riskReport.getFileName());
                }
            } else {
                riskReport.setStatus(RiskReport.STATUS_FAIL);
                log.info("生成风评报告失败：{}", riskReport.getFileName());
            }
            reportRepository.save(riskReport);
        }).start();
    }

    /**
     * 生成文件路径
     *
     * @param fileName
     * @param suffix
     * @return
     */
    private String generateFilePath(String fileName, String suffix) {
        return fileProperties.getPath().getPath() +
                FileConstant.FILE_SEPARATE +
                FileConstant.RISK_REPORT_FOLDER +
                FileConstant.FILE_SEPARATE +
                fileName + suffix;
    }

    /**
     * 生成文件
     *
     * @param report 风评报告实体
     */
    private boolean createReport(RiskReport report) {
        Map<String, String> mapReplaceValues = new HashMap<>(64);
        String R1 = report.getName();
        String targetPath = fileProperties.getPath().getPath() +
                FileConstant.RISK_REPORT_FOLDER +
                FileConstant.FILE_SEPARATE +
                generateFileName(report.getFileName());
        String sourcePath = fileProperties.getPath().getPath() +
                FileConstant.TEMPLATE_FILE_FOLDER +
                FileConstant.FILE_SEPARATE +
                FileConstant.TemplateFile.RISK_REPORT_TEMPLE_FILE.getFileName() +
                FileConstant.TemplateFile.RISK_REPORT_TEMPLE_FILE.getFileSuffix();
        //报表生成日期
        String R2 = DateUtils.SIMPLE_DFY_MD.format(report.getCreateTime());
        String R6 = DateUtils.DFY_MD.format(report.getCreateTime().toLocalDateTime());
        //编号
        String R3 = report.getId().toString();
        //风险发现日期
        String R5 = DateUtils.DFY_MD.format(report.getStartTime().toLocalDateTime()) +
                "至" +
                DateUtils.DFY_MD.format(report.getEndTime().toLocalDateTime());
        //风险类型
        String R8 = getRiskType(report.getType());
        //资产范围
        String R4 = getAssetRange(report.getRange(), report.getRangeList());
        //监测资产数
        String[] assetNum = getAssetNum(report.getRange(), report.getRangeList());
        String R9 = assetNum[1];
        String R10 = assetNum[0];
        //漏洞列表
        List<VulnerabilityEs> vulnerabilityList = getVulnerabilityList(R4, report);
        int all = vulnerabilityList.size();
        List<VulnerabilityEs> lowList = new ArrayList<>();
        List<VulnerabilityEs> midList = new ArrayList<>();
        List<VulnerabilityEs> highList = new ArrayList<>();
        vulnerabilityList.forEach(e -> {
            if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_LOW) {
                lowList.add(e);
            } else if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_MID) {
                midList.add(e);
            } else if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_HIGH) {
                highList.add(e);
            }
        });
        String R11 = lowList.size() + "";
        String R12 = midList.size() + "";
        String R13 = highList.size() + "";
        //应用 高危
        String R14 = countNum(highList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R15 = countNum(highList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R41 = countNum(highList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R16 = (Long.parseLong(R14) + Long.parseLong(R15) + Long.parseLong(R41)) + "";
        //应用 中危
        String R17 = countNum(midList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R18 = countNum(midList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R42 = countNum(midList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R19 = (Long.parseLong(R17) + Long.parseLong(R18) + Long.parseLong(R42)) + "";
        //应用 低危
        String R20 = countNum(lowList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R21 = countNum(lowList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R43 = countNum(lowList, VulnerabilityEs.CATEGORY_WEB, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R22 = (Long.parseLong(R20) + Long.parseLong(R21) + Long.parseLong(R43)) + "";
        //主机 高危
        String R23 = countNum(highList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R24 = countNum(highList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R44 = countNum(highList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R25 = (Long.parseLong(R23) + Long.parseLong(R24) + Long.parseLong(R44)) + "";
        //主机 中危
        String R26 = countNum(midList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R27 = countNum(midList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R45 = countNum(midList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R28 = (Long.parseLong(R26) + Long.parseLong(R27) + Long.parseLong(R45)) + "";
        //主机 低危
        String R29 = countNum(lowList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR,
                VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
        String R30 = countNum(lowList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_TO_RETEST,
                VulnerabilityEs.HANDLE_STATUS_CLOSED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
        String R46 = countNum(lowList, VulnerabilityEs.CATEGORY_HOST, VulnerabilityEs.HANDLE_STATUS_IGNORED);
        String R31 = (Long.parseLong(R29) + Long.parseLong(R30) + Long.parseLong(R46)) + "";
        //风险资产top10
        List<HashMap<String, String>> riskTop10 = getRiskAssetTop10(report, R4);
        StringBuilder R32 = new StringBuilder();
        if (!riskTop10.isEmpty()) {
            R32.append(RISK_TOP10_HEAD);
        }
        for (HashMap map : riskTop10) {
            R32.append(HTML_TR1);
            R32.append(HTML_TD1).append(map.get("ip")).append(HTML_TD2);
            R32.append(HTML_TD1).append(map.get("head")).append(HTML_TD2);
            R32.append(HTML_TD1).append(map.get("high")).append(HTML_TD2);
            R32.append(HTML_TD1).append(map.get("mid")).append(HTML_TD2);
            R32.append(HTML_TD1).append(map.get("low")).append(HTML_TD2);
            R32.append(HTML_TD1).append(map.get("sum")).append(HTML_TD2);
            R32.append(HTML_TR2);
        }
        if (!riskTop10.isEmpty()) {
            R32.append(RISK_TOP10_TAIL);
        }
        //漏洞详情
        HashMap<String, HashMap<String, Object>> details = getDetail(vulnerabilityList);
        StringBuilder R36 = new StringBuilder();
        boolean isFirst = true;
        for (Map map : details.values()) {
            String affectAssets = "(" + map.get("num") + "/" + all + ") " + map.get("ip");
            VulnerabilityEs vul = (VulnerabilityEs) map.get("vul");
            Map vulDetail = vul.getDetail();
            if (isFirst) {
                R36.append(DETAIL_HEAD);
                isFirst = false;
            } else {
                R36.append(DETAIL_HEAD_BORDER_TOP_NONE);
            }
            //名称
            R36.append(HTML_TR1).append(HTML_TH1).append(vul.getName()).append(HTML_TH2).append(HTML_TR2);
            //影响资产
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(AFFECT_ASSETS).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(affectAssets).append(HTML_TD2).append(HTML_TR2);
            //cve
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(CVE_NAME).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(map.get("code")).append(HTML_TD2).append(HTML_TR2);
            //漏洞描述
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(DESC_NAME).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(
                    vulDetail.getOrDefault(VulnerabilityEs.DETAIL_KEY_DESCRIPTION, ""));
            R36.append(HTML_TD2).append(HTML_TR2);
            //漏洞细节
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(DETAIL_NAME).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(
                    vulDetail.getOrDefault(VulnerabilityEs.DETAIL_KEY_DETAILS, ""));
            R36.append(HTML_TD2).append(HTML_TR2);
            //漏洞影响
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(AFFECT_NAME).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(
                    vulDetail.getOrDefault(VulnerabilityEs.DETAIL_KEY_IMPACT, ""));
            R36.append(HTML_TD2).append(HTML_TR2);
            //处置建议
            R36.append(HTML_TR1).append(DETAIL_KEY_TD).append(ADVICE_NAME).append(HTML_TD2);
            R36.append(DETAIL_VALUE_TD).append(
                    vulDetail.getOrDefault(VulnerabilityEs.DETAIL_KEY_SOLUTION, ""));
            R36.append(HTML_TD2).append(HTML_TR2);
            R36.append(DETAIL_TAIL);
        }
        mapReplaceValues.put("<%=R32%>", R32.toString());
        mapReplaceValues.put("<%=R36%>", R36.toString());
        mapReplaceValues.put("<%=R1%>", R1);
        mapReplaceValues.put("<%=R2%>", R2);
        mapReplaceValues.put("<%=R3%>", R3);
        mapReplaceValues.put("<%=R4%>", R4);
        mapReplaceValues.put("<%=R5%>", R5);
        mapReplaceValues.put("<%=R6%>", R6);
        mapReplaceValues.put("<%=R8%>", R8);
        mapReplaceValues.put("<%=R9%>", R9);
        mapReplaceValues.put("<%=R10%>", R10);
        mapReplaceValues.put("<%=R11%>", R11);
        mapReplaceValues.put("<%=R12%>", R12);
        mapReplaceValues.put("<%=R13%>", R13);
        mapReplaceValues.put("<%=R14%>", R14);
        mapReplaceValues.put("<%=R15%>", R15);
        mapReplaceValues.put("<%=R16%>", R16);
        mapReplaceValues.put("<%=R17%>", R17);
        mapReplaceValues.put("<%=R18%>", R18);
        mapReplaceValues.put("<%=R19%>", R19);
        mapReplaceValues.put("<%=R20%>", R20);
        mapReplaceValues.put("<%=R21%>", R21);
        mapReplaceValues.put("<%=R22%>", R22);
        mapReplaceValues.put("<%=R23%>", R23);
        mapReplaceValues.put("<%=R24%>", R24);
        mapReplaceValues.put("<%=R25%>", R25);
        mapReplaceValues.put("<%=R26%>", R26);
        mapReplaceValues.put("<%=R27%>", R27);
        mapReplaceValues.put("<%=R28%>", R28);
        mapReplaceValues.put("<%=R29%>", R29);
        mapReplaceValues.put("<%=R30%>", R30);
        mapReplaceValues.put("<%=R31%>", R31);
        mapReplaceValues.put("<%=R41%>", R41);
        mapReplaceValues.put("<%=R42%>", R42);
        mapReplaceValues.put("<%=R43%>", R43);
        mapReplaceValues.put("<%=R44%>", R44);
        mapReplaceValues.put("<%=R45%>", R45);
        mapReplaceValues.put("<%=R46%>", R46);
        return FileUtils.generateReplaceFile(sourcePath, targetPath, mapReplaceValues);
    }

    /**
     * 漏洞详情 根据漏洞编号去重
     *
     * @param vulnerabilityList
     * @return
     */
    private HashMap<String, HashMap<String, Object>> getDetail(List<VulnerabilityEs> vulnerabilityList) {
        //去重结果
        HashMap<String, HashMap<String, Object>> resMap = new HashMap();
        for (VulnerabilityEs e : vulnerabilityList) {
            HashMap<String, Object> curMap = new HashMap<>();
            String code = e.getVulNumber();
            if (StringUtils.isEmpty(code)) {
                //无code直接存
                curMap.put("code", "");
                curMap.put("num", 1);
                curMap.put("vul", e);
                curMap.put("ip", e.getIp());
                resMap.put(UUID.randomUUID().toString(), curMap);
                continue;
            }
            //有code
            if (resMap.containsKey(code)) {
                HashMap<String, Object> temp = resMap.get(code);
                //资产数累加
                temp.put("num", Integer.parseInt(temp.get("num").toString()) + 1);
                //ip累加
                temp.put("ip", temp.get("ip") + "," + e.getIp());
            } else {
                curMap.put("code", code);
                curMap.put("num", 1);
                curMap.put("vul", e);
                curMap.put("ip", e.getIp());
                resMap.put(code, curMap);
            }
        }
        return resMap;
    }

    /**
     * 统计 根据风险等级、漏洞类型、处置状态
     *
     * @param list
     * @param category
     * @param status
     * @return
     */
    private String countNum(List<VulnerabilityEs> list, int category, int... status) {
        Long num = 0L;
        if (status.length == 1) {
            num = list.stream().filter(e -> e.getVulCategory() == category && e.getHandleStatus() == status[0]).count();
        } else if (status.length == 2) {
            num = list.stream().filter(e -> e.getVulCategory() == category &&
                    (e.getHandleStatus() == status[0] || e.getHandleStatus() == status[1])).count();
        } else if (status.length == 3) {
            num = list.stream().filter(e -> e.getVulCategory() == category &&
                    (e.getHandleStatus() == status[0] || e.getHandleStatus() == status[1] ||
                            e.getHandleStatus() == status[2])).count();
        }
        return num.toString();
    }

    /**
     * 风险top10 详细信息
     *
     * @param report
     * @param range
     * @return
     */
    private List<HashMap<String, String>> getRiskAssetTop10(RiskReport report, String range) {
        List<HashMap<String, String>> mapList = new ArrayList<>();
        List<String> ipList = getAssetTop10(report, range);
        ipList.forEach(ip -> {
            VulnerabilityQueryDto queryDto = new VulnerabilityQueryDto();
            queryDto.setIp(ip);
            List<VulnerabilityEs> vulnerabilityEsList = new ArrayList<>();
            vulnerabilityEsList = queryVulnerability(vulnerabilityEsList, queryDto, 1);
            AtomicInteger low = new AtomicInteger();
            AtomicInteger mid = new AtomicInteger();
            AtomicInteger high = new AtomicInteger();
            vulnerabilityEsList.forEach(e -> {
                if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_LOW) {
                    low.getAndIncrement();
                } else if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_MID) {
                    mid.getAndIncrement();
                } else if (e.getRiskLevel() == VulnerabilityEs.RISK_LEVEL_HIGH) {
                    high.getAndIncrement();
                }
            });
            HashMap<String, String> map = new HashMap<>();
            map.put("ip", ip);
            map.put("low", low.toString());
            map.put("mid", mid.toString());
            map.put("high", high.toString());
            map.put("sum", vulnerabilityEsList.size() + "");
            map.put("head", getAssetHead(ip));
            mapList.add(map);
        });
        return mapList;
    }

    /**
     * 获取资产负责人
     *
     * @param ip
     * @return
     */
    private String getAssetHead(String ip) {
        Asset asset = assetService.getHostAssetByIp(ip);
        if (asset != null && asset.getDept() != null) {
            return userService.getDeptHead(asset.getDept().getId()).getNickName();
        }
        return "";
    }

    /**
     * 风险top10 es查询获取ip
     *
     * @param report
     * @param range
     * @return
     */
    private List getAssetTop10(RiskReport report, String range) {
        List<String> resList = new ArrayList<>();
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        //最新漏扫结果
        boolQueryBuilder.must(QueryBuilders.termQuery("latest", true));
        //时间范围
        boolQueryBuilder.must(QueryBuilders.rangeQuery("findTime").
                gte(new Date(report.getStartTime().getTime())).
                lte(new Date(report.getEndTime().getTime())));
        //类型 全部不加条件
        if (report.getType() == RiskReport.TYPE_HOST) {
            boolQueryBuilder.must(QueryBuilders.termQuery("vulCategory", VulnerabilityEs.CATEGORY_HOST));
        } else if (report.getType() == RiskReport.TYPE_WEB) {
            boolQueryBuilder.must(QueryBuilders.termQuery("vulCategory", VulnerabilityEs.CATEGORY_WEB));
        }
        //资产范围 全部不加条件
        if (report.getRange() == RiskReport.RANGE_SINGLE) {
            boolQueryBuilder.must(QueryBuilders.termQuery("ip", range));
        } else if (report.getRange() == RiskReport.RANGE_DEPT) {
            boolQueryBuilder.must(QueryBuilders.termsQuery("deptName", range.split(SEPARATE_STR)));
        }
        //分页
        NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder().withPageable(PageRequest.of(0, 1));
        //聚合
        TermsAggregationBuilder group = AggregationBuilders.terms("group").field("ip").size(10);
        Query query = queryBuilder.
                withQuery(boolQueryBuilder).
                withAggregations(group).build();
        // 执行查询
        SearchHits<VulnerabilityEs> esSearchHits = esRestTemplate.search(query, VulnerabilityEs.class);
        Aggregations aggregations = (Aggregations) esSearchHits.getAggregations().aggregations();
        Terms agg = aggregations.get("group");
        List<Terms.Bucket> buckets = (List<Terms.Bucket>) agg.getBuckets();
        for (Terms.Bucket bucket : buckets) {
            resList.add(bucket.getKeyAsString());
        }
        return resList;
    }


    /**
     * 生成文件名
     *
     * @param fileName 文件名
     * @return 返回文件名
     */
    private String generateFileName(String fileName) {
        return fileName + FileConstant.HTML_SUFFIX_HTML;
    }

    /**
     * 根据类型获取名称
     *
     * @param i 类型
     * @return 类型名称
     */
    private String getRiskType(int i) {
        switch (i) {
            case RiskReport.TYPE_HOST:
                return "主机漏洞";
            case RiskReport.TYPE_WEB:
                return "应用漏洞";
            case RiskReport.TYPE_ALL:
                return "主机漏洞、应用漏洞";
            default:
        }
        return "";
    }

    /**
     * 获取资产范围
     *
     * @param i   范围类型
     * @param str 范围列表
     * @return 范围名称
     */
    private String getAssetRange(int i, String str) {
        switch (i) {
            case RiskReport.RANGE_SINGLE:
                return str;
            case RiskReport.RANGE_DEPT:
                List<Long> list = Arrays.stream(str.split(RegexUtil.IP_SEPARATOR)).
                        map(Long::parseLong).collect(Collectors.toList());
                List<Dept> deptList = deptRepository.findAllById(list);
                StringBuilder range = new StringBuilder();
                for (Dept d : deptList) {
                    range.append(d.getName()).append(SEPARATE_STR);
                }
                if (deptList.isEmpty()) {
                    return "";
                } else {
                    return range.substring(0, range.lastIndexOf(SEPARATE_STR));
                }
            case RiskReport.RANGE_ALL:
                return "全部";
            default:
        }
        return "";
    }

    /**
     * 获取监测资产数量
     *
     * @param i   范围类型
     * @param str 范围列表
     * @return 资产数量
     */
    private String[] getAssetNum(int i, String str) {
        String hostNum = "0";
        String webNum = "0";
        switch (i) {
            case RiskReport.RANGE_SINGLE:
                List<Asset> assetList = assetRepository.findAllByIpAndAssetCategory(str, Asset.CATEGORY_HOST);
                if (!assetList.isEmpty()) {
                    hostNum = "1";
                    webNum = assetRepository.countByParentIdEquals(assetList.get(0).getId()).toString();
                }
                break;
            case RiskReport.RANGE_DEPT:
                List<Long> list = Arrays.stream(str.split(RegexUtil.IP_SEPARATOR)).
                        map(Long::parseLong).collect(Collectors.toList());
                List<Dept> deptList = deptRepository.findAllById(list);
                List<Asset> assets = assetRepository.findAllByDeptIn(deptList);
                Integer host = assets.size();
                hostNum = host.toString();
                webNum = assetRepository.countByParentIn(assets).toString();
                break;
            case RiskReport.RANGE_ALL:
                hostNum = assetRepository.countAllByAssetCategoryEquals(Asset.CATEGORY_HOST).toString();
                webNum = assetRepository.countAllByAssetCategoryEquals(Asset.CATEGORY_PORT).toString();
                break;
            default:
        }
        return new String[]{hostNum, webNum};
    }

    /**
     * 获取漏洞列表 根据报告参数
     *
     * @param range  资产范围
     * @param report 报告
     * @return 漏洞列表
     */
    private List<VulnerabilityEs> getVulnerabilityList(String range, RiskReport report) {
        int i = report.getRange();
        int type = report.getType();
        VulnerabilityQueryDto queryDto = new VulnerabilityQueryDto();
        //时间范围
        List<Date> findTime = new ArrayList<>();
        findTime.add(DateUtils.toDate(report.getStartTime().toLocalDateTime()));
        findTime.add(DateUtils.toDate(report.getEndTime().toLocalDateTime()));
        queryDto.setFindTime(findTime);
        //类型 全部类型无条件
        if (type == RiskReport.TYPE_HOST) {
            queryDto.setCategory(VulnerabilityEs.CATEGORY_HOST);
        } else if (type == RiskReport.TYPE_WEB) {
            queryDto.setCategory(VulnerabilityEs.CATEGORY_WEB);
        }
        //资产范围 查询所有无条件
        if (i == RiskReport.RANGE_SINGLE) {
            queryDto.setIp(range);
        } else if (i == RiskReport.RANGE_DEPT) {
            queryDto.setDepts(Arrays.asList(range.split(SEPARATE_STR)));
        }
        List<VulnerabilityEs> vulnerabilityEsList = new ArrayList<>();
        return queryVulnerability(vulnerabilityEsList, queryDto, 1);
    }

    /**
     * 递归查询漏洞
     *
     * @param list     漏洞列表
     * @param queryDto 查询参数
     * @param page     当前页数
     * @return 漏洞列表
     */
    private List<VulnerabilityEs> queryVulnerability(List<VulnerabilityEs> list, VulnerabilityQueryDto queryDto, int page) {
        int size = 1000;
        Pageable pageable = PageRequest.of(page - 1, size);
        queryDto.setPageable(pageable);
        Page<VulnerabilityEs> temp = vulnerabilityEsService.query(queryDto, true);
        list.addAll(temp.getContent());
        if (page < temp.getTotalPages()) {
            return queryVulnerability(list, queryDto, page + 1);
        } else {
            return list;
        }
    }


    /**
     * 单个删除
     *
     * @param id id
     */
    @Override
    public void delById(Long id) {
        reportRepository.deleteById(id);
    }

    /**
     * 删除报表
     *
     * @param batchPackage 批量参数
     */
    @Override
    public void delBatch(BatchPackage batchPackage) {
        if (batchPackage.isAll()) {
            reportRepository.deleteAll();
        } else {
            reportRepository.deleteAllById(batchPackage.getIds());
        }
    }

    /**
     * 下载文件
     *
     * @param request
     * @param response
     * @param dto
     */
    @Override
    public void downloadFile(HttpServletRequest request, HttpServletResponse response, RiskReportDto dto) {
        RiskReport report = reportRepository.findById(dto.getId()).orElse(null);
        if (report == null) {
            log.info("无此风评报告，{}", dto.getId());
        }
        File file = new File(generateFilePath(report.getFileName(), dto.getSuffix()));
        FileUtils.downloadFile(file, response, request, report.getName(), false);
    }

    /**
     * 查看html详情
     *
     * @param request
     * @param response
     * @param dto
     */
    @Override
    public void viewFile(HttpServletRequest request, HttpServletResponse response, RiskReportDto dto) {
        RiskReport report = reportRepository.findById(dto.getId()).orElse(null);
        if (report == null) {
            log.info("无此风评报告，{}", dto.getId());
        }
        File file = new File(generateFilePath(report.getFileName(), FileConstant.HTML_SUFFIX_HTML));
        FileUtils.downloadFile(file, response, request, report.getName(), true);
    }


}
