package com.cumulus.modules.business.vulnerability.service.impl;


import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.vulnerability.dto.ScanDto;
import com.cumulus.modules.business.vulnerability.entity.Scan;
import com.cumulus.modules.business.vulnerability.entity.ScanPlan;
import com.cumulus.modules.business.vulnerability.mapstruct.ScanMapper;
import com.cumulus.modules.business.vulnerability.repository.ScanPlanRepository;
import com.cumulus.modules.business.vulnerability.repository.ScanRepository;
import com.cumulus.modules.business.vulnerability.service.ScanService;
import com.cumulus.mysql.utils.QueryableIncludeOrSpecification;
import com.cumulus.utils.RegexUtil;
import com.cumulus.utils.RsaUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import javax.transaction.Transactional;
import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.Optional;

/**
 * 漏洞扫描器服务实现
 *
 * @author zhaoff
 */
@Service
@Slf4j
public class ScanServiceImpl implements ScanService {

    /**
     * 扫描器数据访问接口
     */
    @Autowired
    private ScanRepository scanRepository;

    /**
     * 扫描任务数据层接口
     */
    @Autowired
    private ScanPlanRepository scanPlanRepository;

    /**
     * 扫描器实体类DTO mapper
     */
    @Autowired
    private ScanMapper scanMapper;

    /**
     * 扫描任务启动类
     */
    @Autowired
    private ScanTaskRunner scanTaskRunner;

    @Override
    public Page<ScanDto> list(Pageable pageable, MultiValueMap<String, String> params) {
        Page<Scan> all = scanRepository.findAll(
                new QueryableIncludeOrSpecification<>(Scan.class, params), pageable);
        return all.map(scanMapper::toDto);
    }

    @Override
    @Transactional(rollbackOn = IOException.class)
    public void addScan(Scan scan) {
        scan.setId(null);
        checkCreate(scan);
        scan.setCreateTime(new Date());
        scanRepository.save(scan);
    }

    @Override
    public void editScan(Scan newScan) {
        String message = checkUpdate(newScan);
        if (message != null) {
            throw new BadRequestException("更新失败," + message);
        }
        scanRepository.save(newScan);
    }

    /**
     * 如果扫描器下有扫描任务,但并未执行. 删除成功
     * 如果扫描器下也有扫描任务,有的在执行有的未执行. 删除失败
     * 扫描器没有扫描任务  删除成功
     *
     * @param scan 扫描器
     */
    @Override
    @Transactional(rollbackOn = IOException.class)
    public void deleteScanner(Scan scan) {
        if (checkScanUsing(scan.getId())) {
            throw new BadRequestException("扫描器下有扫描任务正在执行,删除失败");
        }
        List<ScanPlan> scanPlanList = scanPlanRepository.findAllByScanner(scan);
        scanRepository.delete(scan);
        for (ScanPlan scanPlan : scanPlanList) {
            // todo 先删除定时任务,在删除扫描任务
            scanPlanRepository.delete(scanPlan);
        }
    }


    /**
     * 根据ID获取漏洞扫描器
     *
     * @param id ID
     * @return 漏洞扫描器
     */
    @Override
    public Scan findById(Long id) {
        return scanRepository.findById(id).orElse(null);
    }

    /**
     * 校验新增的扫描器对象
     *
     * @param scan 新增的扫描对象
     */
    private String checkCreate(Scan scan) {
        // 对名称,接口地址,用户名和密码 进行校验
        if (!RegexUtil.regexNumAndCharAndChinese(scan.getName(), Scan.SCAN_NAME_MAX_LENGTH) ||
                !RegexUtil.regexPortAddress(scan.getScanAddress(), Scan.ADDRESS_MAX_LENGTH) ||
                !RegexUtil.regexNumAndCharAndChinese(scan.getScanUsername(), Scan.USERNAME_MAX_LENGTH) ||
                !RegexUtil.regexNumAndChar(scan.getScanPassword(), Scan.PASSWORD_MAX_LENGTH)) {
            return "字段有误";
        }
        List<Scan> scanAll = scanRepository.findAllByName(scan.getName());
        //假如该列表存在数据逻辑上应该只存在1条数据如果 scan 存在id 说明是更新 需要判断该数据和更新的id 是否相同不同不能更新 2、 如果不存在id说明是新增则不能更新
        boolean checkName = !scanAll.isEmpty() && (scan.getId() == null || !scanAll.get(0).getId().equals(scan.getId()));
        if (checkName) {
            return "扫描器名称已存在";
        }
        return null;
    }


    /**
     * 查看扫描器是否被使用
     */
    private boolean checkScanUsing(Long scanId) {
        if (scanId == null) {
            return false;
        }
        Scan scan = new Scan();
        scan.setId(scanId);
        List<ScanPlan> planList = scanPlanRepository.findAllByScanner(scan);
        for (ScanPlan plan : planList) {
            if (scanTaskRunner.isScanPlanRunning(plan.getId())) {
                return true;
            }
        }
        return false;
    }

    /**
     * 校验更新的扫描器对象
     *
     * @param newScan 新的对象
     */
    private String checkUpdate(Scan newScan) {
        if (newScan.getId() == null) {
            return "需要id";
        }
        Optional<Scan> oldScanOpt = scanRepository.findById(newScan.getId());
        if (!oldScanOpt.isPresent()) {
            return "对象不存在";
        }
        Scan oldScan = oldScanOpt.get();
        if (checkScanUsing(oldScan.getId())) {
            return "当前运行中的任务正在使用该扫描器";
        }
        if (newScan.getScanAddress() == null) {
            newScan.setScanAddress(oldScan.getScanAddress());
        }
        if (newScan.getScanUsername() == null) {
            newScan.setScanUsername(oldScan.getScanUsername());
        }
        if (newScan.getScanPassword() == null) {
            newScan.setScanPassword(oldScan.getScanPassword());
        } else {
            try {
                newScan.setScanPassword(RsaUtils.encryptByPublicKey(Scan.SCAN_PWD_RSA_PUBLIC_KEY, newScan.getScanPassword()));
            } catch (Exception e) {
                return "密码存在问题";
            }
        }
        if (newScan.getName() == null) {
            newScan.setName(oldScan.getName());
        }
        if (newScan.getProduct() == null) {
            newScan.setProduct(oldScan.getProduct());
        }
        if (newScan.getVersion() == null) {
            newScan.setVersion(oldScan.getVersion());
        }
        return checkCreate(newScan);
    }
}
