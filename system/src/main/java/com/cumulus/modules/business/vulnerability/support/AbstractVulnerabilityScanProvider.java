package com.cumulus.modules.business.vulnerability.support;

import com.cumulus.modules.business.service.AssetService;
import com.cumulus.modules.business.vulnerability.dto.ScanTaskRequest;
import com.cumulus.modules.business.vulnerability.entity.AssetScanResult;
import com.cumulus.modules.business.vulnerability.entity.ScanPlan;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.repository.AssetScanResultRepository;
import com.cumulus.modules.business.vulnerability.repository.ScanPlanRepository;
import com.cumulus.modules.business.vulnerability.repository.ScanRepository;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityEsRepository;
import com.cumulus.modules.business.vulnerability.service.AssetScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanPlanService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityEsService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityHistoryEsService;
import com.cumulus.modules.business.vulnerability.service.impl.ScanTaskRunner;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.util.EntityUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


/**
 * 漏洞扫描抽象类
 *
 * @author zhaoff
 */
@Slf4j
public abstract class AbstractVulnerabilityScanProvider implements VulnerabilityScanProvider {

    /**
     * json mapper
     */
    protected ObjectMapper mapper = new ObjectMapper();

    /**
     * 扫描计划数据访问层
     */
    @Autowired
    private ScanPlanRepository scanPlanRepository;

    /**
     * 漏洞扫描器数据访问对象
     */
    @Autowired
    protected ScanRepository scannerRepository;

    /**
     * 任务状态控制类
     */
    @Lazy
    @Autowired
    private ScanTaskRunner scanTaskRunner;

    /**
     * 资产扫描结果数据访问接口
     */
    @Autowired
    private AssetScanResultRepository assetScanResultRepository;

    /**
     * 扫描任务服务
     */
    @Autowired
    private ScanPlanService scanPlanService;

    /**
     * 单个扫描结果服务
     */
    @Autowired
    private AssetScanResultService assetScanResultService;

    /**
     * 漏洞数据接口
     */
    @Autowired
    private VulnerabilityEsRepository vulnerabilityEsRepository;

    /**
     * 漏洞服务类
     */
    @Autowired
    private VulnerabilityEsService vulnerabilityEsService;

    /**
     * 资产服务接口
     */
    @Autowired
    private AssetService assetService;

    /**
     * 漏洞历史服务
     */
    @Autowired
    private VulnerabilityHistoryEsService vulnerabilityHistoryEsService;

    @Override
    public void batchAddScanTask(ScanTaskRequest request) throws Exception {
        ScanPlan plan = scanPlanService.getScanPlanById(request.getPlanId());
        if (plan == null) {
            if (log.isDebugEnabled()) {
                log.warn("plan not exist");
            }
            throw new Exception("plan not exist");
        }
        List<String> scanIpList = assetScanResultService.findAllByScanResultId(plan.getRunningOrLastResultId())
                .stream().map(AssetScanResult::getIp).collect(Collectors.toList());
        if (scanIpList.isEmpty()) {
            // 扫描计划中所有的设备都已创建过扫描任务，包括创建成功或未成功
            if (log.isDebugEnabled()) {
                log.warn("All scan dev have been submitted, plan name:" + plan.getName());
            }
            throw new Exception("asset not find");
        }
        // 漏扫器上漏扫任务ID
        try {
            String taskId = createBatchScanTask(request, scanIpList);
            //存入到任务的数据中 需要使用自己的 runGetStatusAndResult 的 provider 会返回 taskId
            if (StringUtils.isNotBlank(taskId)) {
                assetScanResultRepository.updateAllTaskIdByScanResultId(taskId, request.getResult().getId());
                plan.getExtra().put("taskId", taskId);
                scanPlanRepository.save(plan);
                request.setPlan(plan);
                //启动获取任务结果线程
                scanTaskRunner.runGetStatusAndResult(request);
            }
        } catch (Exception e) {
            throw new Exception("vul task start error");
        }
    }

    @Override
    public void batchGetScanResult(ScanTaskRequest request) {
        List<AssetScanResult> scanAssetList = assetScanResultRepository.findAllByScanResult(request.getResult());
        for (AssetScanResult assetResult : scanAssetList) {
            //状态为扫描中的才去获取数据
            if (!((Integer) AssetScanResult.RESULT_RUNNING).equals(assetResult.getResult())) {
                continue;
            }
            getScanResult(request, assetResult);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void stopScanTask(ScanTaskRequest request) {
    }

    @Override
    public void saveVulList(ScanTaskRequest request, List<Long> assetIdList, String vulIp, List<VulnerabilityEs> vulList, int vulType) {
        vulnerabilityEsService.updateLatestByVulCategoryAndId(vulType, vulIp);
        vulnerabilityEsRepository.saveAll(vulList);
        List<String> vulIdList = vulList.stream().map(VulnerabilityEs::getId).collect(Collectors.toList());
        assetScanResultService.updateEndAssetScanReason(vulIp, request.getResult().getId(), vulIdList);
        for (VulnerabilityEs vul : vulList) {
            vulnerabilityHistoryEsService.vulNewDiscovery(vul.getId());
        }
        for (Long assetId : assetIdList) {
            assetService.updateRiskStatus(assetId);
        }
        scanTaskRunner.tryEndScanTask(request);
    }

    /**
     * 按扫描器类型分类获取扫描结果
     *
     * @param request 扫描任务请求
     * @param devId   设备ID
     * @return 扫描结果
     * @throws Exception 异常
     */
    Map<String, Object> getScanResultByScan(ScanTaskRequest request, Integer devId) throws Exception {
        /*VulnerabilityScan scanner = (VulnerabilityScan) request.getExtra().get(AssetConstants.SCANNER);
        if (scanner == null) {
            throw new ScannerException(commonService.getString("Scanner.not.exist"));
        }
        String[] fields = {
                VulnerabilityDetail.FIELD_ID,
                VulnerabilityDetail.FIELD_PLUGIN_ID,
                VulnerabilityDetail.FIELD_DETAIL_PORT
        };
        int pageSize = GatherConstants.MAX_SCROLL_PAGESIZE;
        BoolQueryBuilder boolQuery = boolQuery().must(QueryBuilders.termQuery(VulnerabilityDetail.FIELD_DEV_ID, devId));
        boolQuery.must(QueryBuilders.termQuery(VulnerabilityDetail.FIELD_SCAN_TYPE, scanner.getScanProduct()));
        boolQuery.must(QueryBuilders.matchQuery(VulnerabilityDetail.FIELD_STATUS, VulnerabilityDetail.STATUS_UNFIXED));
        NativeSearchQueryBuilder queryBuilder =
                new NativeSearchQueryBuilder().withIndices(VulnerabilityDetail.ES_INDEX_VULN)
                        .withTypes(VulnerabilityDetail.ES_TYPE_VULN)
                        .withPageable(new PageableImpl(0, pageSize, null));
        SearchQuery searchQuery = queryBuilder.withFilter(boolQuery).withFields(fields).build();
        List<Map<String, Object>> vulnInfos = queryInfoWithFields(searchQuery, fields);
        Map<String, Object> oldVulnMap = new HashMap<>();
        for (Map<String, Object> vulnInfo : vulnInfos) {
            String pluginIdPort;
            if (CommUtils.checkNull(vulnInfo, VulnerabilityDetail.FIELD_PLUGIN_ID)) {
                pluginIdPort = vulnInfo.get(VulnerabilityDetail.FIELD_PLUGIN_ID).toString() + "#";
            } else {
                continue;
            }
            if (CommUtils.checkNull(vulnInfo, VulnerabilityDetail.FIELD_DETAIL_PORT)) {
                pluginIdPort = pluginIdPort + vulnInfo.get(VulnerabilityDetail.FIELD_DETAIL_PORT).toString();
            }
            oldVulnMap.put(pluginIdPort, vulnInfo);
        }
        return oldVulnMap;*/
        return null;
    }

    /**
     * 获取请求数据，返回序列化数据
     *
     * @param resp 请求返回数据
     * @return 序列化的数据
     */
    @SuppressWarnings("unchecked")
    protected Map<String, Object> getHttpResponseData(HttpResponse resp) {
        BufferedReader reader = null;
        Map<String, Object> respMap = null;
        try {
            reader = new BufferedReader(new InputStreamReader(resp.getEntity().getContent(), StandardCharsets.UTF_8));
            StringBuilder buffer = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                if (log.isDebugEnabled()) {
                    log.debug("line is " + line);
                }
                buffer.append(line);
                if (log.isDebugEnabled()) {
                    log.debug(String.valueOf(buffer));
                }
            }
            respMap = mapper.readValue(buffer.toString(), Map.class);
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error(e.getMessage());
            }
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    if (log.isErrorEnabled()) {
                        log.error(e.getMessage());
                    }
                }
            }
        }
        return respMap;
    }

    /**
     * 对漏扫器 url 进行检验
     *
     * @param address 扫描器中存储的 url 地址
     * @return url数据
     */
    protected String[] parseUrl(String address) {
        URL url;
        try {
            url = new URL(address);
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error("New scanner url exception");
            }
            return null;
        }
        String proto = url.getProtocol();
        String host = url.getHost();
        int port = url.getPort();
        String addr = host;
        if (port != -1) {
            addr = host + ":" + port;
        }
        return new String[]{proto, addr};
    }

    /**
     * 生产请求url
     *
     * @param proto   协议，http或https
     * @param address 访问地址，可能包含端口
     * @param path    访问路径
     * @return 请求url
     */
    protected String genRequestUrl(String proto, String address, String path) {
        return proto + "://" + address + path;
    }

    /**
     * httpClient 请求结束后，释放连接，防止因response的entity未消费导致连接永远不会释放回池中
     *
     * @param request  http请求
     * @param response http响应
     */
    protected void releaseHttpConnection(HttpRequestBase request, CloseableHttpResponse response) {
        try {
            if (null != response) {
                if (null != response.getEntity()) {
                    EntityUtils.consume(response.getEntity());
                }
                response.close();
            }

            if (request != null) {
                request.abort();
            }
        } catch (Exception e) {
            // ignore
        }
    }

}
