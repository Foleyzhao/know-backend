package com.cumulus.modules.business.vulnerability.service.impl;

import com.cumulus.enums.MessageTypeEnum;
import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.entity.Asset;
import com.cumulus.modules.business.entity.AssetExtend;
import com.cumulus.modules.business.repository.AssetRepository;
import com.cumulus.modules.business.service.AssetService;
import com.cumulus.modules.business.vulnerability.common.model.BuiltInVulReceiveModel;
import com.cumulus.modules.business.vulnerability.common.model.BuiltInVulSendModel;
import com.cumulus.modules.business.vulnerability.common.service.impl.VulSendBean;
import com.cumulus.modules.business.vulnerability.dto.ScanRetestDto;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityHistoryEs;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityEsRepository;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityHistoryEsRepository;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityEsService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityHistoryEsService;
import com.cumulus.modules.business.vulnerability.support.EngineScanProvider;
import com.cumulus.modules.system.entity.Dept;
import com.cumulus.modules.system.entity.User;
import com.cumulus.modules.system.repository.UserRepository;
import com.cumulus.modules.system.service.MessageService;
import com.cumulus.modules.system.service.UserService;
import com.cumulus.utils.DateUtils;
import com.cumulus.utils.SecurityUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

/**
 * 漏洞处置服务实现类
 *
 * @author : shenjc
 */
@Service
@Slf4j
public class VulnerabilityHistoryEsServiceImpl implements VulnerabilityHistoryEsService {

    /**
     * 资产数据接口
     */
    @Autowired
    private AssetRepository assetRepository;

    /**
     * 资产服务类
     */
    @Autowired
    private AssetService assetService;

    /**
     * 用户服务
     */
    @Autowired
    private UserService userService;

    /**
     * 用户数据接口
     */
    @Autowired
    private UserRepository userRepository;

    /**
     * 漏洞历史数据接口
     */
    @Autowired
    private VulnerabilityHistoryEsRepository vulnerabilityHistoryEsRepository;

    /**
     * 漏洞数据接口
     */
    @Autowired
    private VulnerabilityEsRepository vulnerabilityEsRepository;

    /**
     * 漏洞服务
     */
    @Autowired
    private VulnerabilityEsService vulnerabilityEsService;

    /**
     * 漏扫mq
     */
    @Autowired
    private VulSendBean vulSendBean;

    /**
     * 系统消息服务
     */
    @Autowired
    private MessageService messageService;

    /**
     * 扫描复测任务前缀
     */
    public static final String SCAN_RETEST_PLAN_PREFIX = "scanRetest-";

    /**
     * 扫描复测 Map Key：IP value：漏洞 id 列表 和创建的时间
     */
    private final ConcurrentHashMap<String, ScanRetestDto> scanRetestMap = new ConcurrentHashMap<>();

    /**
     * 扫描复测任务超时时间
     */
    public static final long SCAN_RETEST_TIME_OUT = 12 * DateUtils.MINUTE_TO_HOUR * DateUtils.SEC_TO_MINUTE * DateUtils.MILLISECOND_TO_SEC;

    /**
     * 扫描复测任务任务队列
     */
    private static final LinkedBlockingQueue<BuiltInVulReceiveModel> RETEST_QUEUE = new LinkedBlockingQueue<>();

    @Override
    public void vulNewDiscovery(String vulId) {
        Optional<VulnerabilityEs> vulOpt = vulnerabilityEsRepository.findById(vulId);
        if (vulOpt.isPresent()) {
            VulnerabilityEs vul = vulOpt.get();
            vul.setHandleStatus(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
            vul.setHandleUser(getHandleUser(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED, null, vul));
            vul.setManageTime(new Date());
            vulnerabilityEsService.saveById(vul);
            VulnerabilityHistoryEs historyEs = new VulnerabilityHistoryEs(vulId, null, VulnerabilityHistoryEs.HANDLE_CODE_NEW, getCurrentUser());
            vulnerabilityHistoryEsRepository.save(historyEs);
            sendMessage(null, VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED, vul, vul.getHandleUser());
        }
    }

    @Override
    public void vulUpdateHandleStatus(String vulId, String reason, Long handleUser, Integer vulHandleStatus, Integer vulActionCode) {
        Optional<VulnerabilityEs> vulOpt = vulnerabilityEsRepository.findById(vulId);
        if (!vulOpt.isPresent() || ObjectUtils.anyNull(vulActionCode)) {
            throw new BadRequestException("操作失败");
        }
        //currentUserId 不会报错 说明是前端发起的需要校验用户
        if (!checkOperation(vulOpt.get().getHandleUser())) {
            throw new BadRequestException("操作失败,当前用户没有权限");
        }
        if (!checkReason(vulHandleStatus, vulActionCode, reason)) {
            throw new BadRequestException("操作失败, 没有原因");
        }
        int newVulHandleStatus = getNextVulHandleStatus(vulHandleStatus, vulActionCode);
        vulOpt.ifPresent(vulnerabilityEs -> {
            if (checkVulHandleStatus(vulnerabilityEs.getHandleStatus(), newVulHandleStatus)) {
                Long nextHandleUser = getHandleUser(newVulHandleStatus, handleUser, vulnerabilityEs);
                sendMessage(vulActionCode, newVulHandleStatus, vulnerabilityEs, nextHandleUser);
                vulnerabilityEs.setHandleUser(nextHandleUser);
                vulnerabilityEs.setHandleStatus(newVulHandleStatus);
                vulnerabilityEs.setManageTime(new Date());
                vulnerabilityEsService.saveById(vulnerabilityEs);
                assetService.updateRiskStatus(Long.parseLong(vulnerabilityEs.getAssetId()));
            } else {
                throw new BadRequestException("操作失败");
            }
        });
        VulnerabilityHistoryEs historyEs = new VulnerabilityHistoryEs(vulId, reason, vulActionCode, getCurrentUser());
        vulnerabilityHistoryEsRepository.save(historyEs);
    }

    @Override
    public void addRetestMessage(BuiltInVulReceiveModel model) {
        RETEST_QUEUE.offer(model);
    }

    @Override
    public int vulRetest(List<String> vulIdList) {
        if (vulIdList == null || vulIdList.isEmpty()) {
            return 0;
        }
        Iterator<VulnerabilityEs> allVul = vulnerabilityEsRepository.findAllById(vulIdList).iterator();
        Map<String, Integer> ipMap = new HashMap<>();
        int countSuccess = 0;
        while (allVul.hasNext()) {
            VulnerabilityEs vul = allVul.next();
            if (vul.getHandleStatus().equals(VulnerabilityEs.HANDLE_STATUS_TO_RETEST)) {
                synchronized (scanRetestMap) {
                    ScanRetestDto scanRetestDto = scanRetestMap.get(vul.getIp());
                    if (scanRetestDto == null) {
                        ipMap.put(vul.getIp(), 0);
                        scanRetestDto = new ScanRetestDto();
                    }
                    if (!scanRetestDto.getVulIdList().contains(vul.getId())) {
                        scanRetestDto.getVulIdList().add(vul.getId());
                        countSuccess++;
                        Integer ipCount = ipMap.get(vul.getIp());
                        if (ipCount != null) {
                            ipMap.put(vul.getIp(), ++ipCount);
                        }
                    }
                    scanRetestMap.put(vul.getIp(), scanRetestDto);
                }
            }
        }
        if (!ipMap.isEmpty()) {
            for (Map.Entry<String, Integer> ipItem : ipMap.entrySet()) {
                String ip = ipItem.getKey();
                try {
                    sendScanRetest(ip);
                } catch (BadRequestException e) {
                    if (log.isInfoEnabled()) {
                        log.info("sendScanRetest error message {}", e.getMessage());
                    }
                    countSuccess = countSuccess - ipItem.getValue();
                    scanRetestMap.remove(ip);
                }
            }
        }
        return countSuccess;
    }

    @Override
    public List<VulnerabilityEs> getAllVulByActionCode(Integer vulActionCode) {
        return vulnerabilityEsRepository.findAllByHandleStatusIn(getNowVulHandleStatus(vulActionCode));
    }

    @Override
    public void scanRetestTask() {
        BuiltInVulReceiveModel message = RETEST_QUEUE.poll();
        while (message != null) {
            //防止报错导致 quartz 任务暂停
            try {
                handleScanRetest(message);
            } catch (Exception e) {
                if (log.isInfoEnabled()) {
                    log.info("scanRetestTask error");
                }
            }
            message = RETEST_QUEUE.poll();
        }
    }

    @Override
    public void scanRetestMapClean() {
        long now = System.currentTimeMillis();
        Collection<String> timeOutList = scanRetestMap.entrySet().stream()
                .filter(entry -> (now - entry.getValue().getCreateTime()) > SCAN_RETEST_TIME_OUT)
                .map(Map.Entry::getKey).collect(Collectors.toList());
        synchronized (scanRetestMap) {
            for (String ip : timeOutList) {
                scanRetestMap.remove(ip);
            }
        }
    }

    @Override
    public void delete(String vulId) {
        Optional<VulnerabilityEs> vulOpt = vulnerabilityEsRepository.findById(vulId);
        if (vulOpt.isPresent()) {
            VulnerabilityEs vul = vulOpt.get();
            if (!((Integer) VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED).equals(vul.getHandleStatus())) {
                throw new BadRequestException("操作失败,非下发状态无法删除");
            }
            if (!checkOperation(vul.getHandleUser())) {
                throw new BadRequestException("操作失败,当前用户没有权限");
            }
            vulnerabilityEsRepository.delete(vul);
            assetService.updateRiskStatus(Long.parseLong(vul.getAssetId()));
        }
    }

    /**
     * 发送扫描复测请求
     *
     * @param ip ip的Set
     */
    private void sendScanRetest(String ip) {
        BuiltInVulSendModel vulSendModel = new BuiltInVulSendModel();
        vulSendModel.setPocScan(true);
        vulSendModel.setWeakPassBrute(true);
        vulSendModel.setVersionMatch(true);
        vulSendModel.setType(BuiltInVulSendModel.DEFAULT_TYPE);
        boolean notSendMessage = true;
        List<Asset> assetList;
        if (ip.contains(EngineScanProvider.WEB_TYPE_MARK)) {
            assetList = new ArrayList<>();
            assetList.add(assetService.getWebAssetByWebSite(ip));
        } else {
            assetList = assetRepository.findAllByIp(ip);
        }
        if (!assetList.isEmpty()) {
            vulSendModel.setId(SCAN_RETEST_PLAN_PREFIX + ip);
            if (ip.contains(EngineScanProvider.WEB_TYPE_MARK)) {
                notSendMessage = false;
                vulSendModel.setTargets(assetList.get(0).getAssetExtend().getWebsite());
                vulSendModel.setTargetType(BuiltInVulSendModel.TARGET_TYPE_WEB);
                vulSendModel.setFingerprint(null);
                //web 不发弱口令检测
                vulSendModel.setWeakPassBrute(false);
                vulSendBean.sendRequestForAsyncResponse(vulSendModel);
                //重新设置弱口令检测
                vulSendModel.setWeakPassBrute(true);
            } else {
                BuiltInVulSendModel.Fingerprint fingerprint = new BuiltInVulSendModel.Fingerprint();
                for (Asset asset : assetList) {
                    AssetExtend extend = asset.getAssetExtend();
                    if (extend != null) {
                        if (StringUtils.isNotBlank(extend.getName())) {
                            final BuiltInVulSendModel.FingerprintDetail fingerprintDetail = new BuiltInVulSendModel.FingerprintDetail();
                            fingerprintDetail.setName(extend.getName());
                            fingerprintDetail.setCpe(extend.getCpe());
                            fingerprintDetail.setProduct(extend.getProduct());
                            fingerprintDetail.setVersion(extend.getVersion());
                            if (AssetExtend.TYPE_TCP.equals(StringUtils.lowerCase(extend.getType()))) {
                                fingerprint.getTcp().put(String.valueOf(asset.getPort()), fingerprintDetail);
                            } else if (AssetExtend.TYPE_UDP.equals(StringUtils.lowerCase(extend.getType()))) {
                                fingerprint.getUdp().put(String.valueOf(asset.getPort()), fingerprintDetail);
                            }
                        }
                    }
                }
                //目前没有指纹就不发单个IP的任务
                if (!fingerprint.getTcp().isEmpty() || !fingerprint.getUdp().isEmpty()) {
                    notSendMessage = false;
                    vulSendModel.setFingerprint(fingerprint);
                    vulSendModel.setTargets(ip);
                    vulSendModel.setTargetType(BuiltInVulSendModel.TARGET_TYPE_HOST);
                    vulSendBean.sendRequestForAsyncResponse(vulSendModel);
                }
            }
        }
        if (notSendMessage) {
            ScanRetestDto scanRetestDto;
            synchronized (scanRetestMap) {
                scanRetestDto = scanRetestMap.get(ip);
                scanRetestMap.remove(ip);
            }
            if (scanRetestDto != null) {
                for (String id : scanRetestDto.getVulIdList()) {
                    vulUpdateHandleStatus(id, "扫描复测通过", null, VulnerabilityEs.HANDLE_STATUS_REPAIR, VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST);
                }
            }
        }
    }

    /**
     * 校验原因是否为空
     *
     * @param vulActionCode 漏洞处置操作码
     * @param reason        原因
     * @return 返回校验是否成功
     */
    private boolean checkReason(Integer vulHandleStatus, Integer vulActionCode, String reason) {
        switch (vulActionCode) {
            case VulnerabilityHistoryEs.HANDLE_CODE_IGNORE:
            case VulnerabilityHistoryEs.HANDLE_CODE_OVERRULE: {
                if (StringUtils.isBlank(reason)) {
                    return false;
                }
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_MANUAL_RETEST: {
                if (((Integer) VulnerabilityEs.HANDLE_STATUS_TO_REPAIR).equals(vulHandleStatus)) {
                    if (StringUtils.isBlank(reason)) {
                        return false;
                    }
                }
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_SUBMIT_RETEST:
            case VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST:
            case VulnerabilityHistoryEs.HANDLE_CODE_NEW:
            case VulnerabilityHistoryEs.HANDLE_CODE_ISSUED:
            case VulnerabilityHistoryEs.HANDLE_CODE_CLOSE:
            default:
        }
        return true;
    }

    /**
     * 校验当前登录用户是否可用操作 可能是定时任务调用无法获取 currentUserId 此时会报错但是也需要返回成功
     *
     * @param vulHandleUser 漏洞操作人id
     * @return 返回是否通过
     */
    private boolean checkOperation(Long vulHandleUser) {
        try {
            Long currentUserId = SecurityUtils.getCurrentUserId();
            if (currentUserId != null) {
                Optional<User> userOpt = userRepository.findById(currentUserId);
                //当前用户存在且为超管则返回true
                if (userOpt.isPresent() && userOpt.get().getIsAdmin()) {
                    return true;
                } else {
                    //判断当前用户id和处置人id是否相同 相同则返回true
                    return currentUserId.equals(vulHandleUser);
                }
            }
        } catch (Exception e) {
            if (log.isInfoEnabled()) {
                log.info("vulUpdateHandleStatus scheduled task can not get currentUserId");
            }
        }
        //报错或者无法获取到 currentUserId 认为是在定时任务中非前端发送请求所以成功
        return true;
    }

    /**
     * 校验漏洞状态码是否可以变更
     *
     * @param oldStatus 老状态
     * @param newStatus 新状态
     * @return 是否可以变更 true 可以变更
     */
    private boolean checkVulHandleStatus(Integer oldStatus, Integer newStatus) {
        if (ObjectUtils.anyNull(oldStatus, newStatus)) {
            return false;
        }
        switch (newStatus) {
            case VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED: {
                if (VulnerabilityEs.HANDLE_STATUS_TO_REPAIR == oldStatus) {
                    return true;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_TO_REPAIR: {
                if (VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED == oldStatus || VulnerabilityEs.HANDLE_STATUS_TO_RETEST == oldStatus) {
                    return true;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_TO_RETEST: {
                if (VulnerabilityEs.HANDLE_STATUS_TO_REPAIR == oldStatus) {
                    return true;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_REPAIR: {
                if (VulnerabilityEs.HANDLE_STATUS_TO_RETEST == oldStatus) {
                    return true;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_IGNORED: {
                if (VulnerabilityEs.HANDLE_STATUS_TO_REPAIR == oldStatus) {
                    return true;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_CLOSED: {
                if (VulnerabilityEs.HANDLE_STATUS_IGNORED == oldStatus || VulnerabilityEs.HANDLE_STATUS_REPAIR == oldStatus) {
                    return true;
                }
            }
            default: {
            }
        }
        return false;
    }

    /**
     * 根据 vulActionCode 生成和校验 vulHandleStatus
     *
     * @param vulHandleStatus 漏洞状态码
     * @param vulActionCode   漏洞状态动作码
     * @return 返回漏洞状态码
     */
    private int getNextVulHandleStatus(Integer vulHandleStatus, Integer vulActionCode) {
        switch (vulActionCode) {
            case VulnerabilityHistoryEs.HANDLE_CODE_ISSUED: {
                return VulnerabilityEs.HANDLE_STATUS_TO_REPAIR;
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_SUBMIT_RETEST: {
                return VulnerabilityEs.HANDLE_STATUS_TO_RETEST;
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_IGNORE: {
                return VulnerabilityEs.HANDLE_STATUS_IGNORED;
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_OVERRULE: {
                return VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED;
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST:
            case VulnerabilityHistoryEs.HANDLE_CODE_MANUAL_RETEST: {
                if (VulnerabilityEs.HANDLE_STATUS_REPAIR == vulHandleStatus || VulnerabilityEs.HANDLE_STATUS_TO_REPAIR == vulHandleStatus) {
                    return vulHandleStatus;
                }
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_CLOSE: {
                return VulnerabilityEs.HANDLE_STATUS_CLOSED;
            }
            default: {
            }
        }
        throw new BadRequestException("无法获取处置状态码");
    }

    /**
     * 根据 vulActionCode 生成和校验 vulHandleStatus
     *
     * @param vulActionCode 漏洞状态动作码
     * @return 返回漏洞状态码
     */
    private List<Integer> getNowVulHandleStatus(Integer vulActionCode) {
        switch (vulActionCode) {
            case VulnerabilityHistoryEs.HANDLE_CODE_ISSUED: {
                return Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED);
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_SUBMIT_RETEST:
            case VulnerabilityHistoryEs.HANDLE_CODE_IGNORE:
            case VulnerabilityHistoryEs.HANDLE_CODE_OVERRULE: {
                return Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_TO_REPAIR);
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST:
            case VulnerabilityHistoryEs.HANDLE_CODE_MANUAL_RETEST: {
                return Collections.singletonList(VulnerabilityEs.HANDLE_STATUS_TO_RETEST);
            }
            case VulnerabilityHistoryEs.HANDLE_CODE_CLOSE: {
                return Arrays.asList(VulnerabilityEs.HANDLE_STATUS_IGNORED, VulnerabilityEs.HANDLE_STATUS_REPAIR);
            }
            default: {
            }
        }
        throw new BadRequestException("无法获取处置状态码");
    }

    /**
     * 获取处理人
     *
     * @param vulHandleStatus 资产状态
     * @param handleUser      指定的处理人
     * @param vul             漏洞实体
     */
    private Long getHandleUser(Integer vulHandleStatus, Long handleUser, VulnerabilityEs vul) {
        Optional<Asset> assetOpt = assetRepository.findById(Long.parseLong(vul.getAssetId()));
        Asset asset = assetOpt.orElse(null);
        if (asset != null) {
            if (Asset.CATEGORY_PORT == asset.getAssetCategory()) {
                Asset assetHost = assetService.getHostAssetByIp(asset.getIp());
                if (assetHost != null) {
                    asset = assetHost;
                }
            }
        }
        switch (vulHandleStatus) {
            case VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED: {
                Dept dept = null;
                if (asset != null) {
                    dept = asset.getDept();
                }
                if (dept != null) {
                    return userService.getDeptHead(dept.getId()).getId();
                } else {
                    return User.DEFAULT_RISK_MANAGER_ID;
                }
            }
            case VulnerabilityEs.HANDLE_STATUS_TO_REPAIR: {
                //风险管理员通过
                if (((Long) User.DEFAULT_RISK_MANAGER_ID).equals(handleUser)) {
                    return handleUser;
                }
                //当前状态为待复测返回待复测时指定的用户
                if (VulnerabilityEs.HANDLE_STATUS_TO_RETEST == vul.getHandleStatus()) {
                    return vul.getHandleUser();
                }
                Optional<User> userOpt = userRepository.findById(handleUser);
                if (asset != null && userOpt.isPresent()) {
                    if (userOpt.get().getDept() != null && asset.getDept() != null) {
                        if (userOpt.get().getDept().getId().equals(asset.getDept().getId())) {
                            return handleUser;
                        } else {
                            vul.setDeptName(asset.getDept().getName());
                            vulnerabilityEsService.saveById(vul);
                        }
                    }
                } else if (asset == null) {
                    //资产不存在删除该漏洞
                    vulnerabilityEsRepository.delete(vul);
                }
                break;
            }
            case VulnerabilityEs.HANDLE_STATUS_TO_RETEST: {
                return vul.getHandleUser();
            }
            case VulnerabilityEs.HANDLE_STATUS_REPAIR:
            case VulnerabilityEs.HANDLE_STATUS_IGNORED: {
                return User.DEFAULT_RISK_MANAGER_ID;
            }
            case VulnerabilityEs.HANDLE_STATUS_CLOSED: {
                try {
                    Long currentUserId = SecurityUtils.getCurrentUserId();
                    if (((Long) User.DEFAULT_RISK_MANAGER_ID).equals(currentUserId)
                            || ((Long) User.DEFAULT_SUPER_MANAGER_ID).equals(currentUserId)) {
                        return currentUserId;
                    }
                } catch (Exception e) {
                    throw new BadRequestException("当前用户无权限关闭");
                }
            }
            default: {
            }
        }
        throw new BadRequestException("无法获取处理人");
    }

    /**
     * 处理复测信息
     *
     * @param message 信息
     */
    private void handleScanRetest(BuiltInVulReceiveModel message) {
        if (log.isInfoEnabled()) {
            log.info("handleScanRetest planId{} targetType {}", message.getPlanId(), message.getTargetType());
        }
        String ip = message.getPlanId().replaceFirst(SCAN_RETEST_PLAN_PREFIX, "");
        ScanRetestDto scanRetestDto;
        synchronized (scanRetestMap) {
            scanRetestDto = scanRetestMap.get(ip);
            scanRetestMap.remove(ip);
        }
        final Iterator<VulnerabilityEs> allVul = vulnerabilityEsRepository.findAllById(scanRetestDto.getVulIdList()).iterator();
        List<BuiltInVulReceiveModel.VulInfo> vulInfos = message.getResList().get(ip);
        Asset asset;
        switch (message.getTargetType()) {
            case BuiltInVulSendModel.TARGET_TYPE_HOST: {
                asset = assetService.getHostAssetByIp(ip);
                break;
            }
            case BuiltInVulSendModel.TARGET_TYPE_WEB: {
                asset = assetService.getWebAssetByWebSite(ip);
                break;
            }
            default: {
                return;
            }
        }
        while (allVul.hasNext()) {
            VulnerabilityEs vul = allVul.next();
            boolean pass = true;
            for (BuiltInVulReceiveModel.VulInfo vulInfo : vulInfos) {
                if (checkSameVul(vulInfo, vul, asset)) {
                    pass = false;
                    break;
                }
            }
            try {
                if (pass) {
                    vulUpdateHandleStatus(vul.getId(), "扫描复测通过", null, VulnerabilityEs.HANDLE_STATUS_REPAIR, VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST);
                } else {
                    vulUpdateHandleStatus(vul.getId(), "扫描复测失败", null, VulnerabilityEs.HANDLE_STATUS_TO_REPAIR, VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST);
                }
            } catch (Exception exception) {
                if (log.isInfoEnabled()) {
                    log.info("handleScanRetest loop error message {}", exception.getMessage());
                }
            }
        }
    }

    /**
     * 校验漏洞是否是同一个
     *
     * @param vulInfo mq收到的漏洞信息
     * @param vul     漏洞es中的信息
     * @param asset   资产信息
     * @return 返回校验是否成功
     */
    private boolean checkSameVul(BuiltInVulReceiveModel.VulInfo vulInfo, VulnerabilityEs vul, Asset asset) {
        if (!vul.getAssetId().equals(String.valueOf(asset.getId()))) {
            return false;
        }
        String identification = vulInfo.getCve();
        if (StringUtils.isNotBlank(identification)) {
            if (identification.equals(vul.getVulNumber()) || identification.equals(vul.getDetail().get(VulnerabilityEs.DETAIL_KEY_CVE_NUMBER))) {
                return true;
            }
        }
        identification = vulInfo.getCnnvd();
        if (StringUtils.isNotBlank(identification)) {
            if (identification.equals(vul.getVulNumber()) || identification.equals(vul.getDetail().get(VulnerabilityEs.DETAIL_KEY_CNVD_NUMBER))) {
                return true;
            }
        }
        identification = vulInfo.getHash();
        if (StringUtils.isNotBlank(identification)) {
            return identification.equals(vul.getVulNumber()) || identification.equals(vul.getDetail().get(VulnerabilityEs.DETAIL_KEY_CVE_IDENTIFYING));
        }
        return false;
    }

    /**
     * 生成系统消息
     *
     * @param vulActionCode       操作吗
     * @param nextVulHandleStatus 下个漏洞状态
     * @param nextHandleUser      处理人
     * @param vulnerabilityEs     漏洞信息
     */
    private void sendMessage(Integer vulActionCode, Integer nextVulHandleStatus, VulnerabilityEs vulnerabilityEs, Long nextHandleUser) {
        if (vulActionCode != null) {
            switch (vulActionCode) {
                case VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST:
                case VulnerabilityHistoryEs.HANDLE_CODE_MANUAL_RETEST: {
                    if (VulnerabilityEs.HANDLE_STATUS_REPAIR == nextVulHandleStatus) {
                        messageService.sendMessage(MessageTypeEnum.RISK_RETEST_SUCCESS_TYPE, new HashSet<>(Collections.singleton(vulnerabilityEs.getHandleUser())), null,
                                vulnerabilityEs.getIp());
                    } else if (VulnerabilityEs.HANDLE_STATUS_TO_REPAIR == nextVulHandleStatus) {
                        messageService.sendMessage(MessageTypeEnum.RISK_RETEST_OVERRULE_TYPE, new HashSet<>(Collections.singleton(vulnerabilityEs.getHandleUser())), null,
                                vulnerabilityEs.getIp());
                    }
                    break;
                }
                case VulnerabilityHistoryEs.HANDLE_CODE_OVERRULE: {
                    User perUser = getPerUserByVulId(vulnerabilityEs.getId());
                    User currentUser = getCurrentUser();
                    messageService.sendMessage(MessageTypeEnum.RISK_ISSUED_OVERRULE_TYPE, new HashSet<>(Collections.singleton(perUser.getId())), null,
                            vulnerabilityEs.getIp());
                    messageService.sendMessage(MessageTypeEnum.RISK_REPAIR_OVERRULE_TYPE, new HashSet<>(Collections.singleton(currentUser.getId())), null,
                            vulnerabilityEs.getIp());
                    break;
                }
                case VulnerabilityHistoryEs.HANDLE_CODE_SUBMIT_RETEST: {
                    User perUser = getPerUserByVulId(vulnerabilityEs.getId());
                    User currentUser = getCurrentUser();
                    messageService.sendMessage(MessageTypeEnum.RISK_ISSUED_SUCCESS_TYPE, new HashSet<>(Collections.singleton(perUser.getId())), null,
                            vulnerabilityEs.getIp());
                    messageService.sendMessage(MessageTypeEnum.RISK_REPAIR_SUCCESS_TYPE, new HashSet<>(Collections.singleton(currentUser.getId())), null,
                            vulnerabilityEs.getIp());
                    break;
                }
                case VulnerabilityHistoryEs.HANDLE_CODE_CLOSE: {
                    User currentUser = getCurrentUser();
                    messageService.sendMessage(MessageTypeEnum.RISK_CLOSE_TYPE, new HashSet<>(Collections.singleton(currentUser.getId())), null,
                            vulnerabilityEs.getIp());
                    break;
                }
                default: {
                    break;
                }
            }
        }
        if (nextVulHandleStatus != null) {
            List<String> jumpParameters = Collections.singletonList(vulnerabilityEs.getId());
            switch (nextVulHandleStatus) {
                case VulnerabilityEs.HANDLE_STATUS_TO_BE_ISSUED: {
                    messageService.sendMessage(MessageTypeEnum.NEW_WAIT_TO_ISSUED_RISK_TYPE, new HashSet<>(Collections.singleton(nextHandleUser)), jumpParameters,
                            vulnerabilityEs.getIp());
                    break;
                }
                case VulnerabilityEs.HANDLE_STATUS_TO_REPAIR: {
                    messageService.sendMessage(MessageTypeEnum.NEW_WAIT_TO_REPAIR_RISK_TYPE, new HashSet<>(Collections.singleton(nextHandleUser)), jumpParameters,
                            vulnerabilityEs.getIp());
                    break;
                }
                case VulnerabilityEs.HANDLE_STATUS_TO_RETEST: {
                    messageService.sendMessage(MessageTypeEnum.NEW_WAIT_TO_RETEST_RISK_TYPE, new HashSet<>(Collections.singleton(nextHandleUser)), jumpParameters,
                            vulnerabilityEs.getIp());
                    break;
                }
                case VulnerabilityEs.HANDLE_STATUS_REPAIR:
                case VulnerabilityEs.HANDLE_STATUS_IGNORED: {
                    messageService.sendMessage(MessageTypeEnum.NEW_WAIT_TO_CLOSE_RISK_TYPE, new HashSet<>(Collections.singleton(nextHandleUser)), jumpParameters,
                            vulnerabilityEs.getIp());
                    break;
                }
                default: {
                    break;
                }
            }
        }
    }

    /**
     * 获取当前用户名 可能是线程调用没有用户名所以使用该方法
     *
     * @return 返回当前用户
     */
    private User getCurrentUser() {
        Long currentUserId;
        try {
            currentUserId = SecurityUtils.getCurrentUserId();
        } catch (BadRequestException exception) {
            currentUserId = User.DEFAULT_SUPER_MANAGER_ID;
        }
        Optional<User> userOpt = userRepository.findById(currentUserId);
        return userOpt.orElse(null);
    }

    /**
     * 获取上一次的用户信息
     *
     * @param vulId 漏洞id
     * @return 返回用户信息
     */
    private User getPerUserByVulId(String vulId) {
        PageRequest uTime = PageRequest.of(0, 1, Sort.Direction.DESC, VulnerabilityHistoryEs.ORDER_FILED_CREATE_TIME);
        Page<VulnerabilityHistoryEs> vulList = vulnerabilityHistoryEsRepository.findAllByVulId(vulId, uTime);
        User user = null;
        if (!vulList.getContent().isEmpty()) {
            user = userRepository.findByUsername(vulList.getContent().get(0).getCreateBy());
        }
        if (user == null) {
            Optional<User> userOpt = userRepository.findById(User.DEFAULT_SUPER_MANAGER_ID);
            user = userOpt.orElse(null);
        }
        return user;
    }
}
