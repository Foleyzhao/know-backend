package com.cumulus.modules.business.vulnerability.service.impl;

import com.cumulus.config.FileProperties;
import com.cumulus.constant.FileConstant;
import com.cumulus.enums.ScanProduct;
import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.vulnerability.entity.AssetScanResult;
import com.cumulus.modules.business.vulnerability.entity.ScanPlan;
import com.cumulus.modules.business.vulnerability.entity.ScanResult;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.repository.ScanPlanRepository;
import com.cumulus.modules.business.vulnerability.repository.ScanResultRepository;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityEsRepository;
import com.cumulus.modules.business.vulnerability.service.AssetScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanResultService;
import com.cumulus.modules.business.vulnerability.support.EngineScanProvider;
import com.cumulus.mysql.utils.QueryableIncludeOrSpecification;
import com.cumulus.utils.CommonUtils;
import com.cumulus.utils.DateUtils;
import com.cumulus.utils.FileUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.transaction.Transactional;
import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * @author : shenjc
 */
@Slf4j
@Service
public class ScanResultServiceImpl implements ScanResultService {

    /**
     * 系统文件属性配置
     */
    @Autowired
    private FileProperties fileProperties;

    /**
     * 扫描结果数据接口
     */
    @Autowired
    private ScanResultRepository scanResultRepository;

    /**
     * 扫描任务数据接口
     */
    @Autowired
    private ScanPlanRepository scanPlanRepository;

    /**
     * 单个扫描结果服务层
     */
    @Autowired
    private AssetScanResultService assetScanResultService;

    /**
     * 漏洞实体数据接口
     */
    @Autowired
    private VulnerabilityEsRepository vulnerabilityEsRepository;

    public static final String VUL_RISK_LOW_HTML = "<td><span class=\"low\"></span>低危</td>";
    public static final String VUL_RISK_HIGH_HTML = "<td><span class=\"high\"></span>高危</td>";
    public static final String VUL_RISK_MIDDLE_HTML = "<td><span class=\"middle\"></span>中危</td>";


    @Override
    @Transactional(rollbackOn = Exception.class)
    public ScanResult saveScanResultByPlan(Long planId) {
        ScanPlan plan = scanPlanRepository.findById(planId).orElse(null);
        if (plan == null) {
            throw new RuntimeException("plan not find");
        }
        ScanResult planResult = new ScanResult(plan);
        planResult = scanResultRepository.save(planResult);
        return planResult;
    }

    @Override
    public void updateScanResultStatus(Long scanResultId, Integer result) {
        Optional<ScanResult> scanResult = scanResultRepository.findById(scanResultId);
        if (!scanResult.isPresent()) {
            if (log.isInfoEnabled()) {
                log.info("updateScanResultStatus error not find scanResultId:{}", scanResultId);
            }
            return;
        }
        scanResult.get().setResult(result);
        //扫描结果的状态变化只会变成成功或者失败所有直接设置结束时间
        scanResult.get().setEndTime(new Date());
        scanResultRepository.save(scanResult.get());
    }

    @Override
    public Page<ScanResult> page(Pageable pageable, MultiValueMap<String, String> params) {
        return scanResultRepository.findAll(
                new QueryableIncludeOrSpecification<>(ScanResult.class, params), pageable);
    }

    @Override
    public boolean exportZip(List<ScanResult> resultList, String filePath) {
        Set<File> fileSet = new HashSet<>();
        Map<String, String> fileNameMap = new HashMap<>(resultList.size());
        for (ScanResult scanResult : resultList) {
            if (org.apache.commons.lang3.StringUtils.isNotBlank(scanResult.getFileName())) {
                fileSet.add(new File(generateReportPath(scanResult.getFileName())));
                fileNameMap.put(generateFileName(scanResult.getFileName()),
                        generateFileName(scanResult.getPlanName() + " " + scanResult.getFileName()));
            }
        }
        try {
            FileUtils.zipFiles(fileSet, filePath, fileNameMap);
        } catch (Exception e) {
            File file = new File(filePath);
            if (file.exists()) {
                boolean delete = file.delete();
            }
            return false;
        }
        return true;
    }

    @Override
    public void downloadVulReport(Long scanResultId, HttpServletRequest request, HttpServletResponse response) {
        Optional<ScanResult> scanResultOpt = scanResultRepository.findById(scanResultId);
        if (!scanResultOpt.isPresent()) {
            throw new BadRequestException("数据不存在");
        }
        ScanResult scanResult = scanResultOpt.get();
        FileUtils.downloadFile(new File(generateReportPath(scanResult.getFileName())), response, request,
                scanResult.getPlanName() + ScanResult.FILE_SUFFIX, true);
    }

    @Override
    public void generateReportFile(Long scanResultId, Long planId) {
        if (scanResultId == null) {
            Optional<ScanPlan> planOpt = scanPlanRepository.findById(planId);
            if (planOpt.isPresent()) {
                scanResultId = planOpt.get().getRunningOrLastResultId();
            }
        }
        if (scanResultId == null) {
            return;
        }
        Optional<ScanResult> resultOpt = scanResultRepository.findById(scanResultId);
        if (!resultOpt.isPresent()) {
            return;
        }
        ScanResult scanResult = resultOpt.get();
        if (generateReportFile(scanResult)) {
            //保存生成的文件
            scanResultRepository.save(scanResult);
        }
    }

    /**
     * 生成文件路径
     *
     * @param fileName 文件名
     * @return 返回路径
     */
    private String generateReportPath(String fileName) {
        return fileProperties.getPath().getPath() +
                FileConstant.FILE_SEPARATE +
                FileConstant.SCAN_RESULT_REPORT_FOLDER +
                FileConstant.FILE_SEPARATE +
                generateFileName(fileName);
    }

    /**
     * 生成文件名
     *
     * @param fileName 文件名
     * @return 返回文件名
     */
    private String generateFileName(String fileName) {
        return fileName + FileConstant.HTML_SUFFIX_HTML;
    }

    /**
     * 生成扫描结果报告
     *
     * @param scanResult 扫描结果对象
     */
    private boolean generateReportFile(ScanResult scanResult) {
        scanResult.setFileName(String.valueOf(System.currentTimeMillis()));
        String targetPath = generateReportPath(scanResult.getFileName());
        String sourcePath = fileProperties.getPath().getPath() +
                FileConstant.FILE_SEPARATE +
                FileConstant.TEMPLATE_FILE_FOLDER +
                FileConstant.FILE_SEPARATE +
                FileConstant.TemplateFile.SCAN_RESULT_TEMPLE_FILE.getFileName() +
                FileConstant.TemplateFile.SCAN_RESULT_TEMPLE_FILE.getFileSuffix();
        String reportTime = DateUtils.SIMPLE_DFY_MD.format(scanResult.getEndTime());
        String ipRange = null;
        String product = null;
        String vulTable = null;
        if (scanResult.isBuiltIn()) {
            product = ScanProduct.BUILTIN_PRODUCT_NAME;
        } else {
            product = scanResult.getScannerName();
        }
        List<AssetScanResult> assetScanResultList = assetScanResultService.findAllByScanResultId(scanResult.getId());
        List<String> vulIdList = new ArrayList<>();
        for (AssetScanResult assetScanResult : assetScanResultList) {
            List<String> vulIds = assetScanResult.getVulnerabilityIdList();
            if (vulIds != null && !vulIds.isEmpty()) {
                vulIdList.addAll(vulIds);
            }
        }
        List<VulnerabilityEs> vulList = new ArrayList<>();
        for (VulnerabilityEs vulnerabilityEs : vulnerabilityEsRepository.findAllById(vulIdList)) {
            vulList.add(vulnerabilityEs);
        }
        final List<String> ipList = assetScanResultList.stream()
                .map(AssetScanResult::getIp)
                .filter(asset -> !asset.contains(EngineScanProvider.WEB_TYPE_MARK))
                .collect(Collectors.toList());
        switch (scanResult.getScanType()) {
            case ScanPlan.SCAN_TYPE_ALL: {
                ipRange = ScanPlan.SCAN_TYPE_ALL_STR;
                break;
            }
            case ScanPlan.SCAN_TYPE_BY_DEPT: {
                ipRange = CommonUtils.getFormatList(scanResult.getScanDeptName(), CommonUtils.COMMON_INTERVAL_CHARACTER);
                break;
            }
            case ScanPlan.SCAN_TYPE_CUSTOM: {
                ipRange = CommonUtils.getFormatList(ipList,
                        CommonUtils.COMMON_INTERVAL_CHARACTER);
                break;
            }
            default: {
            }
        }
        final List<VulnerabilityEs> hostVulList = vulList.stream().filter(vul -> {
            return vul.getVulCategory() == VulnerabilityEs.CATEGORY_HOST;
        }).collect(Collectors.toList());
        vulTable = getVulTable(vulList);
        Map<String, String> map = new HashMap<>(13);
        map.put(FileConstant.SCAN_RESULT_REPORT_TIME, reportTime);
        map.put(FileConstant.SCAN_RESULT_IP_RANGE, ipRange);
        map.put(FileConstant.SCAN_RESULT_MONITORING_TYPE, null);
        map.put(FileConstant.SCAN_RESULT_START_TIME, DateUtils.SIMPLE_DFY_MD_HMS.format(scanResult.getStartTime()));
        map.put(FileConstant.SCAN_RESULT_END_TIME, DateUtils.SIMPLE_DFY_MD_HMS.format(scanResult.getEndTime()));
        map.put(FileConstant.SCAN_RESULT_TOOK_TIME, DateUtils.getIntervalTime(scanResult.getStartTime().getTime(), scanResult.getEndTime().getTime()));
        map.put(FileConstant.SCAN_RESULT_VUL_TABLE, vulTable);
        map.put(FileConstant.SCAN_RESULT_RESULT_STR, scanResult.switchResultStr());
        map.put(FileConstant.SCAN_RESULT_PRODUCT, product);
        map.put(FileConstant.SCAN_RESULT_IP_NUM, String.valueOf(ipList.size()));
        map.put(FileConstant.SCAN_RESULT_VUL_NUM, String.valueOf(vulList.size()));
        map.put(FileConstant.SCAN_RESULT_PLAN_NAME, scanResult.getPlanName());
        map.put(FileConstant.SCAN_RESULT_HOST_VUL_NUM, String.valueOf(hostVulList.size()));
        map.put(FileConstant.SCAN_RESULT_WEB_VUL_NUM, String.valueOf(vulList.size() - hostVulList.size()));
        return FileUtils.generateReplaceFile(sourcePath, targetPath, map);
    }

    /**
     * 返回漏洞表的html 字符串
     *
     * @param vulList 漏洞列表
     * @return 返回字符串
     */
    private String getVulTable(List<VulnerabilityEs> vulList) {
        StringBuilder vulTable = new StringBuilder();

        Map<String, List<VulnerabilityEs>> vulMap = new HashMap<>(8);
        for (VulnerabilityEs vul : vulList) {
            List<VulnerabilityEs> list = vulMap.computeIfAbsent(vul.getIp(), k -> new ArrayList<>());
            list.add(vul);
        }
        for (Map.Entry<String, List<VulnerabilityEs>> vulEntry : vulMap.entrySet()) {
            boolean isFirst = true;
            for (VulnerabilityEs vul : vulEntry.getValue()) {
                vulTable.append(CommonUtils.HTML_TR);
                if (isFirst) {
                    if (vulEntry.getValue().size() > 1) {
                        vulTable.append(String.format(CommonUtils.HTML_TABLE_ROWS, vulEntry.getValue().size()));
                    } else {
                        vulTable.append(CommonUtils.HTML_TD);
                    }
                    vulTable.append(vul.getIp()).append(CommonUtils.HTML_BACKSLASH_TD);
                }
                vulTable.append(CommonUtils.HTML_TD).append(vul.getName()).append(CommonUtils.HTML_BACKSLASH_TD);
                vulTable.append(getVulRiskHtml(vul.getRiskLevel()));
                vulTable.append(CommonUtils.HTML_TD).append(vul.getVulNumber()).append(CommonUtils.HTML_BACKSLASH_TD);
                vulTable.append(CommonUtils.HTML_TD).append(vul.getDetail().get(VulnerabilityEs.DETAIL_KEY_CVSS_SCORE)).append(CommonUtils.HTML_BACKSLASH_TD);
                vulTable.append(CommonUtils.HTML_BACKSLASH_TR);
                isFirst = false;
            }

        }

        return vulTable.toString();
    }

    /**
     * 获取风险级别的html字符串
     *
     * @param vulRisk 风险级别
     * @return 返回字符串
     */
    private String getVulRiskHtml(Integer vulRisk) {
        switch (vulRisk) {
            case VulnerabilityEs.RISK_LEVEL_LOW: {
                return VUL_RISK_LOW_HTML;
            }
            case VulnerabilityEs.RISK_LEVEL_MID: {
                return VUL_RISK_MIDDLE_HTML;
            }
            case VulnerabilityEs.RISK_LEVEL_HIGH: {
                return VUL_RISK_HIGH_HTML;
            }
            default: {
            }
        }
        return VUL_RISK_LOW_HTML;
    }
}
