package com.cumulus.modules.business.vulnerability.service.impl;

import com.cumulus.modules.business.vulnerability.service.RemoteSiteService;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.springframework.stereotype.Service;

import javax.annotation.PreDestroy;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 远程站点的服务实现
 *
 * @author zhaoff
 */
@Slf4j
@Service
public class RemoteSiteServiceImpl implements RemoteSiteService {

    /**
     * REST请求客户端缓存 Map
     */
    private ConcurrentHashMap<String, CloseableHttpClient> clientMap = new ConcurrentHashMap<>();

    @Override
    public CloseableHttpClient initClient(String serverIp) {
        return initClient(serverIp, 100000);
    }

    @Override
    public CloseableHttpClient initClient(String serverIp, int timeout) {
        if (log.isDebugEnabled()) {
            log.debug("Init client for server :" + serverIp);
        }

        String key = String.format("%s:%s", serverIp, timeout);
        if (serverIp != null && clientMap.containsKey(key)) {
            return clientMap.get(key);
        }
        CloseableHttpClient client = null;
        try {
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, new TrustManager[]{new TrustAnyTrustManager()}, null);
            SSLConnectionSocketFactory sslConnectionSocketFactory =
                    new SSLConnectionSocketFactory(sc, NoopHostnameVerifier.INSTANCE);
            client = HttpClients.custom().disableCookieManagement()
                    .setSSLSocketFactory(sslConnectionSocketFactory)
                    .setMaxConnPerRoute(1000).setDefaultRequestConfig(
                            RequestConfig.custom().setConnectionRequestTimeout(timeout)
                                    .setConnectTimeout(timeout).setSocketTimeout(timeout).build())
                    .build();
        } catch (Exception e) {
            if (log.isWarnEnabled()) {
                log.warn("init client for server :" + serverIp + " exception", e);
            }
        }

        if (client != null && serverIp != null) {
            clientMap.put(key, client);
        }
        return client;
    }

    /**
     * 销毁方法，回收资源
     */
    @PreDestroy
    public void destroy() {
        clientMap = null;
    }

}
