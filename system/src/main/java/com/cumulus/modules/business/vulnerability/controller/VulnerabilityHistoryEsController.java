package com.cumulus.modules.business.vulnerability.controller;

import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.vulnerability.dto.VulDisposalDto;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityEs;
import com.cumulus.modules.business.vulnerability.entity.es.VulnerabilityHistoryEs;
import com.cumulus.modules.business.vulnerability.repository.VulnerabilityHistoryEsRepository;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityEsService;
import com.cumulus.modules.business.vulnerability.service.VulnerabilityHistoryEsService;
import com.cumulus.modules.security.dto.JwtUserDto;
import com.cumulus.modules.system.dto.UserDto;
import com.cumulus.modules.system.entity.Menu;
import com.cumulus.modules.system.entity.User;
import com.cumulus.modules.system.mapstruct.UserMapper;
import com.cumulus.modules.system.repository.UserRepository;
import com.cumulus.modules.system.service.UserService;
import com.cumulus.utils.SecurityUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 漏洞历史记录控制层
 *
 * @author : shenjc
 */
@RestController
@RequestMapping(path = "/api/vulnerabilityHis")
@Slf4j
@PreAuthorize("@auth.check('riskDisposal')")
public class VulnerabilityHistoryEsController {

    /**
     * 漏洞历史服务
     */
    @Autowired
    private VulnerabilityHistoryEsService vulnerabilityHistoryEsService;

    /**
     * 漏洞数据接口
     */
    @Autowired
    private VulnerabilityHistoryEsRepository vulnerabilityHistoryEsRepository;

    /**
     * 用户服务
     */
    @Autowired
    private UserService userService;

    /**
     * 用户服务
     */
    @Autowired
    private UserRepository userRepository;

    /**
     * 用户转换服务
     */
    @Autowired
    private UserMapper userMapper;

    /**
     * 漏洞服务
     */
    @Autowired
    private VulnerabilityEsService vulnerabilityEsService;

    /**
     * 根据漏洞id 获取漏洞历史记录 创建时间倒序
     *
     * @param vulId 漏洞id
     */
    @PostMapping("listByVulId")
    public ResponseEntity<Object> listByVulId(String vulId) {
        return new ResponseEntity<>(vulnerabilityHistoryEsRepository.findAllByVulIdOrderByCreateTimeDesc(vulId), HttpStatus.OK);
    }

    /**
     * 风险处置
     * 更新漏洞处置状态
     * vulActionCode 0、发现 1、下发 2、提交复测 3、忽略 4、驳回 5、人工复测 6、扫描复测 7、关闭
     * 5、人工复测需要结果（vulHandleStatus） 1、待修复 或者 3、已修复
     * 2、提交复测 3、忽略 4、驳回 5、人工复测 6、扫描复测 以上操作需要原因
     * 1、下发 需要handleUser 操作人id
     *
     * @param dto * 必须要 查询条件
     */
    @PostMapping("/riskDisposal")
    public ResponseEntity<Object> riskDisposal(@Validated(VulDisposalDto.single.class) @RequestBody VulDisposalDto dto) {
        if (dto.getVulIdList() == null || dto.getVulIdList().isEmpty()) {
            throw new BadRequestException("操作失败");
        }
        if (((Integer) VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST).equals(dto.getVulActionCode())) {
            int countSuccess = vulnerabilityHistoryEsService.vulRetest(Collections.singletonList(dto.getVulIdList().get(0)));
            if (countSuccess == 0) {
                throw new BadRequestException("操作失败");
            }
        } else {
            vulnerabilityHistoryEsService.vulUpdateHandleStatus(dto.getVulIdList().get(0), dto.getReason(), dto.getHandleUser()
                    , dto.getVulHandleStatus(), dto.getVulActionCode());
        }
        return new ResponseEntity<>("操作成功", HttpStatus.OK);
    }

    /**
     * 风险处置批量
     * 更新漏洞处置状态
     *
     * @param dto * 必须要 查询条件
     */
    @PostMapping("/riskDisposalBatch")
    public ResponseEntity<Object> riskDisposalBatch(@Validated(VulDisposalDto.batch.class) @RequestBody VulDisposalDto dto) {
        List<String> vulIdList = dto.getVulIdList();
        if (VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST == dto.getVulActionCode()) {
            int countSuccess = vulnerabilityHistoryEsService.vulRetest(vulIdList);
            String result = String.format("共%s条漏洞,其中成功%s条,失败%s条", vulIdList.size(), countSuccess, vulIdList.size() - countSuccess);
            return new ResponseEntity<>(result, HttpStatus.OK);
        }
        int failCount = 0;
        for (String vulId : vulIdList) {
            try {
                vulnerabilityHistoryEsService.vulUpdateHandleStatus(vulId, dto.getReason(), dto.getHandleUser(), dto.getVulHandleStatus(), dto.getVulActionCode());
            } catch (RuntimeException e) {
                failCount++;
            }
        }
        String result = String.format("共%s条漏洞,其中成功%s条,失败%s条", vulIdList.size(), vulIdList.size() - failCount, failCount);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    /**
     * 风险处置批量
     * 更新漏洞处置状态
     *
     * @param dto * 必须要 查询条件
     */
    @PostMapping("/riskDisposalAll")
    public ResponseEntity<Object> riskDisposalAll(@Validated(VulDisposalDto.all.class) @RequestBody VulDisposalDto dto) {
        dto.getVulDto().setIsHandle(true);
        long countSuccess = 0;
        long countFail = 0;
        long totalElements;
        int nowPage = 0;
        int size = 100;
        long nowSize;
        do {
            dto.getVulDto().setPageable(PageRequest.of(nowPage, size));
            Page<VulnerabilityEs> vulPage = vulnerabilityEsService.query(dto.getVulDto(), false);
            totalElements = vulPage.getTotalElements();
            List<String> vulIdList = vulPage.getContent().stream().map(VulnerabilityEs::getId).collect(Collectors.toList());
            if (VulnerabilityHistoryEs.HANDLE_CODE_SCAN_RETEST == dto.getVulActionCode()) {
                countSuccess += vulnerabilityHistoryEsService.vulRetest(vulIdList);
                countFail = totalElements - countSuccess;
            } else {
                for (String vulId : vulIdList) {
                    try {
                        vulnerabilityHistoryEsService.vulUpdateHandleStatus(vulId, dto.getReason(), dto.getHandleUser(), dto.getVulHandleStatus(), dto.getVulActionCode());
                    } catch (RuntimeException e) {
                        countFail++;
                    }
                }
                countSuccess = totalElements - countFail;
            }
            nowPage++;
            nowSize = (long) nowPage * size;
        } while (nowSize < totalElements);
        String result = String.format("共%s条漏洞,其中成功%s条,失败%s条", totalElements, countSuccess, countFail);
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    /**
     * 获取下发用下拉列表
     *
     * @param deptName 部门名称
     * @return 返回列表
     */
    @PostMapping("/getHandleUserListByDeptName")
    public ResponseEntity<Object> getHandleUserListByDeptName(String deptName) {
        List<User> userList = userRepository.findByMenuIdAndDeptName(Menu.DEFAULT_RISK_DISPOSAL_MENU_ID, deptName);
        boolean hasRiskManager = userList.stream().anyMatch(user -> user.getId().equals(User.DEFAULT_RISK_MANAGER_ID));
        List<UserDto> result = userList.stream().map(userMapper::toDto).collect(Collectors.toList());
        if (!hasRiskManager) {
            UserDto riskManager = userService.findById(User.DEFAULT_RISK_MANAGER_ID);
            if (ObjectUtils.allNotNull(riskManager)) {
                result.add(riskManager);
            }
        }
        return new ResponseEntity<>(result, HttpStatus.OK);
    }

    /**
     * 根据ip查询
     *
     * @param vulId 漏洞id
     */
    @DeleteMapping("/deleteById")
    public ResponseEntity<Object> delete(String vulId) {
        vulnerabilityHistoryEsService.delete(vulId);
        return new ResponseEntity<>("删除成功", HttpStatus.OK);
    }

    /**
     * 校验风险处置用户
     *
     * @param vulIdList 漏洞id
     */
    @PostMapping("/checkDisposalUser")
    public ResponseEntity<Object> checkDisposalUser(@RequestBody List<String> vulIdList) {
        JwtUserDto currentUser = (JwtUserDto) SecurityUtils.getCurrentUser();
        Boolean isAdmin = currentUser.getUser().getIsAdmin();
        Map<String, Boolean> result = new HashMap<>(vulIdList.size());
        for (String vulId : vulIdList) {
            //超级管理员拥有处置权限
            if (isAdmin != null && isAdmin) {
                result.put(vulId, true);
            } else {
                Long id = currentUser.getUser().getId();
                VulnerabilityEs vul = vulnerabilityEsService.findById(vulId);
                //能查出漏洞并且 漏洞处置人和当前用户id相同 拥有处置权限
                if (vul != null && id.equals(vul.getHandleUser())) {
                    result.put(vulId, true);
                } else {
                    result.put(vulId, false);
                }
            }
        }
        return new ResponseEntity<>(result, HttpStatus.OK);
    }
}
