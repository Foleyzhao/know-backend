package com.cumulus.modules.business.vulnerability.service.impl;

import com.cumulus.exception.BadRequestException;
import com.cumulus.modules.business.vulnerability.dto.ScanTaskRequest;
import com.cumulus.modules.business.vulnerability.entity.AssetScanResult;
import com.cumulus.modules.business.vulnerability.entity.ScanPlan;
import com.cumulus.modules.business.vulnerability.entity.ScanResult;
import com.cumulus.modules.business.vulnerability.repository.ScanPlanRepository;
import com.cumulus.modules.business.vulnerability.service.AssetScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanPlanService;
import com.cumulus.modules.business.vulnerability.service.ScanResultService;
import com.cumulus.modules.business.vulnerability.service.ScanTaskService;
import com.cumulus.modules.quartz.service.QuartzJobService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.transaction.Transactional;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 漏扫任务执行runner
 *
 * @author zhaoff
 */
@Slf4j
@Component
public class ScanTaskRunner {

    /**
     * 漏洞扫描执行线程的名称
     */
    private static final String EXECUTE_SCAN_THREAD = "VulnerabilityScanExecuteThread-";

    /**
     * 漏洞扫描线程池轮巡调度间隔时间，单位 根据具体 TimeUint
     */
    private static final int SCHEDULE_INTERVAL_GET_RESULT = 60;

    /**
     * 漏洞扫描线程池初始化延迟时间，单位 根据具体 TimeUint
     */
    private static final int INITIAL_DELAY = 0;

    /**
     * 漏洞扫描服务
     */
    @Autowired
    private ScanTaskService scanTaskService;

    /**
     * 扫描计划数据访问接口
     */
    @Autowired
    private ScanPlanRepository scanPlanRepository;

    /**
     * 扫描任务服务层
     */
    @Autowired
    private ScanPlanService scanPlanService;

    /**
     * 定时任务服务层
     */
    @Autowired
    private QuartzJobService quartzJobService;

    /**
     * 单个扫描结果服务层
     */
    @Autowired
    private AssetScanResultService assetScanResultService;

    /**
     * 扫描结果服务层
     */
    @Autowired
    private ScanResultService scanResultService;

    /**
     * 扫描计划执行时的信息，键为扫描计划的id，值为一个map，这个map的键有total, current
     */
    private final Map<Long, ScanTaskRequest> runningInfo = new HashMap<>();

    /**
     * 校验超时任务的线程名
     */
    private static final String TIME_OUT_CHECK_THREAD_NAME = "vul-scan-plan-time-out-check";

    /**
     * 12 小时的毫秒数
     */
    private static final long TIME_OUT = 12 * 60 * 60 * 1000;

    /**
     * 初始化
     */
    @PostConstruct
    public void init() {
        if (log.isInfoEnabled()) {
            log.info("vulScanTask init start");
        }
        List<ScanPlan> allRunningPlan = scanPlanService.findAllRunningPlan();
        for (ScanPlan plan : allRunningPlan) {
            ScanTaskRequest request = new ScanTaskRequest();
            request.setPlanId(plan.getId());
            errorEndScanTask(request, ScanResult.RESULT_FAIL_PROJECT_RESTART, AssetScanResult.RESULT_FAIL_PROJECT_RESTART);
        }
        Thread timeOutCheckThread = new Thread(() -> {
            while (true) {
                try {
                    {
                        List<ScanPlan> allTimeOutPlan = scanPlanRepository.findAllTimeOutPlan(new Date(System.currentTimeMillis() - TIME_OUT));
                        for (ScanPlan plan : allTimeOutPlan) {
                            ScanTaskRequest request = new ScanTaskRequest();
                            request.setPlanId(plan.getId());
                            errorEndScanTask(request, ScanResult.RESULT_FAIL_TIME_OUT, AssetScanResult.RESULT_FAIL_TIME_OUT);
                        }
                    }
                    Thread.sleep(30 * 60 * 1000);
                } catch (Exception e) {
                    if (log.isErrorEnabled()) {
                        log.error("resolveMessageThread error", e);
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (Exception ex) {
                        if (log.isErrorEnabled()) {
                            log.error("resolveMessageThread sleep error", ex);
                        }
                    }
                }
            }
        });
        timeOutCheckThread.setDaemon(true);
        timeOutCheckThread.setName(TIME_OUT_CHECK_THREAD_NAME);
        timeOutCheckThread.start();
    }

    /**
     * 漏扫执行线程
     */
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10, new ThreadFactory() {
        // 线程ID
        private final AtomicLong threadId = new AtomicLong();

        @Override
        public Thread newThread(Runnable runnable) {
            Thread thread = new Thread(runnable);
            thread.setDaemon(true);
            thread.setName(EXECUTE_SCAN_THREAD + threadId.getAndIncrement());
            return thread;
        }
    });

    /**
     * 异步处理扫描任务的入口方法
     *
     * @param request 任务请求
     */
    @Transactional(rollbackOn = Exception.class)
    public void runAsync(ScanTaskRequest request) {
        executeTaskRequest(request);
    }

    /**
     * 执行任务请求
     *
     * @param request 扫描任务请求
     */
    private void executeTaskRequest(ScanTaskRequest request) {
        if (null == request) {
            throw new BadRequestException("参数有误,启动失败");
        }
        //对执行中的任务信息列表加锁
        synchronized (runningInfo) {
            Long planId = request.getPlanId();
            //任务id null 无法执行
            if (planId == null) {
                if (log.isWarnEnabled()) {
                    log.warn("Request is executing but the plan id is null");
                }
                throw new BadRequestException("参数有误,启动失败");
            }
            //没有数据库中没有 plan 对象无法启动
            ScanPlan plan = scanPlanRepository.findById(request.getPlanId()).orElse(null);
            if (plan == null) {
                if (log.isErrorEnabled()) {
                    log.error("Request is executing but the plan not exist, planId: " + request.getPlanId());
                }
                throw new BadRequestException("任务不存在,启动失败");
            }
            //更新下次启动时间 因为可能手动执行了一个任务未完成 之后该任务又自动执行 执行失败但是下次执行时间不变 所以在这里更新
            if (plan.getQuartzJob() != null) {
                plan.setNextTime(quartzJobService.getNextFireTime(plan.getQuartzJob().getId()));
            }
            scanPlanRepository.save(plan);
            //存在重复id 无法执行
            if (runningInfo.containsKey(planId)) {
                if (log.isDebugEnabled()) {
                    log.info("This plan is already running:" + planId);
                }
                throw new BadRequestException("任务执行中,启动失败");
            }
            request.setPlan(plan);
            //保存任务信息在执行中的任务信息列表
            if (!scanPlanService.updatePlanStatus(planId, ScanPlan.SCAN_RUNNING)) {
                throw new BadRequestException("任务状态修改失败");
            }
            runningInfo.put(planId, request);
        }
        //创建线程执行命令
        try {
            ScheduledFuture<?> future =
                    scheduler.schedule(new VulnerabilityScanThread(request), INITIAL_DELAY, TimeUnit.SECONDS);
            request.setFuture(future);
        } catch (Exception e) {
            if (log.isErrorEnabled()) {
                log.error("Execute vulnerability scan request exception, plan:" + request.getPlanId());
            }
            throw new BadRequestException("线程启动失败");
        }
    }

    /**
     * 根据planId获取ScanTaskRequest
     *
     * @param planId planId
     * @return ScanTaskRequest
     */
    public ScanTaskRequest getScanTaskRequest(Long planId) {
        if (null == planId) {
            log.warn("plan id is null");
            return null;
        }
        synchronized (runningInfo) {
            if (runningInfo.containsKey(planId)) {
                // 获取ScanTaskRequest
                return runningInfo.get(planId);
            } else {
                log.warn("plan id no execute");
                return null;
            }
        }
    }

    /**
     * 执行漏洞扫描
     *
     * @param request 任务请求
     */
    private void scanVulnerability(ScanTaskRequest request) {
        try {
            initTaskRequest(request);
            scanTaskService.batchAddActiveScan(request);
        } catch (Exception e) {
            if (log.isWarnEnabled()) {
                log.warn("Scan vulnerability failed", e);
            }
            errorEndScanTask(request, ScanResult.RESULT_FAIL, AssetScanResult.RESULT_FAIL_PROCESSING_ERROR);
        }
    }

    /**
     * 初始化任务请求
     *
     * @param request 任务请求
     */
    void initTaskRequest(ScanTaskRequest request) throws Exception {
        ScanPlan plan = scanPlanRepository.findById(request.getPlanId()).orElse(null);
        if (null == plan) {
            if (log.isErrorEnabled()) {
                log.error("Request is executing but the plan not exist, planId:" + request.getPlanId());
            }
            throw new Exception("plan not exist");
        }
        if (!plan.getBuiltIn()) {
            if (null == plan.getScanner()) {
                throw new Exception("scanner not exist");
            } else {
                request.setScannerId(plan.getScanner().getId());
            }
        }
        plan.lastTime();
        if (plan.getQuartzJob() != null) {
            plan.setNextTime(quartzJobService.getNextFireTime(plan.getQuartzJob().getId()));
        }
        ScanResult planResult = scanResultService.saveScanResultByPlan(request.getPlanId());
        request.setResult(planResult);
        plan.setRunningOrLastResultId(planResult.getId());
        scanPlanRepository.save(plan);
        scanPlanService.updatePlanStatus(request.getPlanId(), ScanPlan.SCAN_RUNNING);
        assetScanResultService.createAssetScanResultList(request.getPlanId());
    }

    /**
     * 暂停扫描任务
     *
     * @param request 任务请求
     */
    void pauseScanTask(ScanTaskRequest request) {
        if (!isScanPlanRunning(request.getPlanId())) {
            throw new RuntimeException("任务未启动");
        }
        scanTaskService.updateTaskStatusPause(request.getPlanId());
    }

    /**
     * 继续扫描任务
     *
     * @param request 任务请求
     */
    void restartScanTask(ScanTaskRequest request) {
        if (!isScanPlanRunning(request.getPlanId())) {
            throw new RuntimeException("任务未启动");
        }
        scanTaskService.updateTaskStatusRestart(request.getPlanId());
    }

    /**
     * 取消扫描任务
     *
     * @param request 任务请求
     */
    void cancelScanTask(ScanTaskRequest request) {
        if (!isScanPlanRunning(request.getPlanId())) {
            throw new RuntimeException("任务未启动");
        }
        if (log.isInfoEnabled()) {
            log.info("vulScan cancelScanTask planId = {}"
                    , request.getPlanId());
        }
        scanTaskService.updateTaskStatusErrorEnd(request.getPlanId(), ScanResult.RESULT_CANCEL, AssetScanResult.RESULT_FAIL_CANCEL);
        endScanTask(request);
        scanResultService.generateReportFile(request.getResult().getId(), null);
    }

    /**
     * 发送错误停止扫描任务
     *
     * @param scanResultResultCode 结果
     * @param request              任务请求
     */
    void errorEndScanTask(ScanTaskRequest request, Integer scanResultResultCode, Integer assetScanResultCode) {
        if (log.isInfoEnabled()) {
            log.info("vulScan errorEndScanTask planId = {} scanResultResultCode = {} assetScanResultCode = {}"
                    , request.getPlanId(), scanResultResultCode, assetScanResultCode);
        }
        scanTaskService.updateTaskStatusErrorEnd(request.getPlanId(), scanResultResultCode, assetScanResultCode);
        endScanTask(request);
        scanResultService.generateReportFile(null, request.getPlanId());
    }

    /**
     * 尝试结束任务
     *
     * @param request 任务信息
     */
    public void tryEndScanTask(ScanTaskRequest request) {
        if (log.isInfoEnabled()) {
            log.info("vulScan tryEndScanTask planId = {}"
                    , request.getPlanId());
        }
        boolean end = scanTaskService.tryUpdateTaskStatusEnd(request.getPlanId());
        if (end) {
            scanResultService.generateReportFile(null, request.getPlanId());
            endScanTask(request);
        }
    }

    /**
     * 结束任务
     *
     * @param request 任务信息
     */
    public void endScanTask(ScanTaskRequest request) {
        Long planId = request.getPlanId();
        synchronized (runningInfo) {
            runningInfo.remove(planId);
        }
        request.cancelTask();
        //重启时没有provider 也不会有线程启动
        if (request.getProvider() != null) {
            request.getProvider().stopScanTask(request);
        }
    }

    /**
     * 异步处理扫描任务的入口方法
     *
     * @param request 任务请求
     */
    public void runGetStatusAndResult(ScanTaskRequest request) {
        executeGetStatusAndResult(request);
    }

    /**
     * 执行获取结果数据
     *
     * @param request 任务请求
     */
    @SuppressWarnings({"unchecked"})
    private void getVulnerabilityResult(ScanTaskRequest request) {
        try {
            scanTaskService.batchGetScanResult(request);
        } catch (Exception e) {
            if (log.isWarnEnabled()) {
                log.warn("Scan vulnerability failed", e);
            }
            errorEndScanTask(request, ScanResult.RESULT_FAIL, AssetScanResult.RESULT_FAIL_PROCESSING_ERROR);
        }
    }

    /**
     * 执行任务请求
     *
     * @param request 扫描任务请求
     */
    private void executeGetStatusAndResult(ScanTaskRequest request) {
        request.setStatusFuture(scheduler.scheduleAtFixedRate(new VulnerabilityScanResultThread(request),
                INITIAL_DELAY, SCHEDULE_INTERVAL_GET_RESULT, TimeUnit.SECONDS));
    }

    /**
     * 扫描计划是否已经在执行
     *
     * @param planId 计划id
     * @return true:是，false：否
     */
    public boolean isScanPlanRunning(Long planId) {
        return runningInfo.containsKey(planId);
    }

    /**
     * 漏洞扫描线程
     *
     * @author zhaoff
     */
    class VulnerabilityScanThread implements Runnable {

        /**
         * 任务请求
         */
        private final ScanTaskRequest request;

        /**
         * 构造函数
         *
         * @param request 任务请求
         */
        public VulnerabilityScanThread(ScanTaskRequest request) {
            this.request = request;
        }

        @Override
        public void run() {
            scanVulnerability(request);
        }

    }

    /**
     * 漏洞扫描线程
     *
     * @author zhaoff
     */
    class VulnerabilityScanResultThread implements Runnable {

        /**
         * 任务请求
         */
        private final ScanTaskRequest request;

        /**
         * 构造函数
         *
         * @param request 任务请求
         */
        public VulnerabilityScanResultThread(ScanTaskRequest request) {
            this.request = request;
        }

        @Override
        public void run() {
            getVulnerabilityResult(request);
        }

    }
}
